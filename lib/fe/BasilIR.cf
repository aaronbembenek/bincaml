rules Module ::= [Decl] ;

terminator Decl ";";

{- TOKENS -}

position token BVTYPE ('b' 'v' digit+) ;
position token INTTYPE {"int"} ;
position token BOOLTYPE {"bool"} ;

{- position token UserIdent '`' ((upper | letter | '_' | '#')(upper | letter | digit | ["_.$#"])*) '`'; -}
position token BIdent '.'((upper | letter | '_')(upper | letter | digit | ["_.$#~"])*) ;

position token LocalIdent ('#' | upper | letter | '_')((upper | letter | digit | ["_.$#"])*);
position token GlobalIdent '$' ((upper | letter | digit | ["_.$#"])+);

position token BlockIdent '%' ((upper | letter | digit | ["_.$#"])+);

separator BlockIdent ",";

position token ProcIdent '@' ((upper | letter | digit | ["_.$#"])+);


position token OpenParen '(' ;
position token CloseParen ')' ;

position token BeginList '[' ;
position token EndList ']' ;
position token BeginRec '{' ;
position token EndRec '}' ;
rules LambdaSep ::= "->" | "::" ;

{- Literals -}

token Str '"' ((char - ["\"\\"]) | ('\\' ["\"\\tnrf"]))* '"' ;
position token IntegerHex ('0' 'x' (digit | ["abcdef"])+);
position token IntegerDec (digit+);

-- gobble extra semicolons 
Semicolons_Empty . Semicolons ::= "";
Semicolons_Some . Semicolons ::= Semicolons  ";" ;

comment "//" ;
comment "/*" "*/" ;

{- Top Level Declarations -}

Shared . VarModifiers ::= "shared" ;
Observable . VarModifiers ::= "observable";
separator VarModifiers "" ;

Decl_Axiom . Decl ::= "axiom" GlobalIdent AttribSet Expr; 
Decl_Mem . Decl ::= "memory" [VarModifiers] GlobalIdent ":" Type VarSpec ;
Decl_Var . Decl ::= "var" [VarModifiers] GlobalIdent ":" Type VarSpec ;

separator Type ",";

Decl_UninterpFun . Decl ::= "val" GlobalIdent AttribSet ":" Type ;

Decl_Fun . Decl ::= "let" GlobalIdent AttribSet ":" Type "=" Expr;
Decl_FunNoType . Decl ::= "let" GlobalIdent AttribSet "=" Expr;
Decl_ProgEmpty . Decl ::= "prog" "entry" ProcIdent AttribSet ;
Decl_ProgWithSpec . Decl ::= "prog" "entry" ProcIdent AttribSet [ ProgSpec ] ;
Decl_Proc . Decl ::= "proc" ProcIdent OpenParen [Params] CloseParen "->" OpenParen [Params] CloseParen AttribSet [ FunSpec ] ProcDef ;

ProcDef_Empty . ProcDef ::= "";
ProcDef_Some  . ProcDef ::= BeginList [Block] EndList ;

IntType1 . IntType ::= INTTYPE ;
BoolType1. BoolType ::= BOOLTYPE ;
MapType1 . MapType ::=  Type "->" Type ;
BVType1 . BVType ::= BVTYPE ;

rules Type ::= IntType | BoolType | MapType | BVType | OpenParen Type CloseParen; 

separator Expr "," ;

IntVal_Hex . IntVal ::= IntegerHex ;
IntVal_Dec . IntVal ::=  IntegerDec ;

rules BVVal ::=  IntVal ":" BVType ;

Endian_Little . Endian ::= "le" ;
Endian_Big . Endian ::= "be" ;

rules Assignment ::= LVar ":=" Expr ;

Stmt_Nop . Stmt ::= "nop";
Stmt_SingleAssign . Stmt ::= Assignment ;
Stmt_MemAssign . Stmt ::= LVar "mem:=" Expr;
Stmt_ScalarStore . Stmt ::= LVar ":=" "store" Expr;
Stmt_ScalarLoad . Stmt ::= LVar ":=" "load" Var ;

separator nonempty Assignment ",";
Stmt_MultiAssign . Stmt ::= OpenParen [Assignment]  CloseParen ;


LocalTyped . LocalVar ::= LocalIdent ":" Type ;
LocalUntyped . LocalVar ::= LocalIdent ;

GlobalTyped . GlobalVar ::= GlobalIdent ":" Type ;
GlobalUntyped . GlobalVar ::= GlobalIdent;
separator nonempty LocalVar ",";
rules Var ::= LocalVar | GlobalVar ;

separator GlobalVar ",";


Stmt_Load . Stmt ::= LVar ":=" "load" Endian GlobalIdent Expr IntVal;
Stmt_Store . Stmt ::= "store" Endian GlobalIdent Expr Expr IntVal;

Stmt_Load_Var . Stmt ::= LVar ":=" "load" Endian Var Expr IntVal;
Stmt_Store_Var . Stmt ::= LVar ":="  "store" Endian Var Expr Expr IntVal;

rules NamedCallReturn ::= LVar "=" LocalIdent;
separator NamedCallReturn "," ;

LVars_Empty . LVars ::= "";
LVars_LocalList . LVars ::= "var" OpenParen [ LocalVar ] CloseParen ":=" ;
LVars_List . LVars ::= OpenParen [ LVar ]  CloseParen ":=";
NamedLVars_List . LVars ::= OpenParen [NamedCallReturn]  CloseParen ":=";

rules NamedCallArg ::= LocalIdent "=" Expr;
separator NamedCallArg "," ;

CallParams_Exprs . CallParams ::= [Expr];
CallParams_Named . CallParams ::= [NamedCallArg];

Stmt_DirectCall . Stmt ::= LVars "call" ProcIdent OpenParen CallParams CloseParen ;
Stmt_IndirectCall . Stmt ::= "indirect" "call" Expr ;

Stmt_Assume . Stmt ::= "assume" Expr ;
Stmt_Guard . Stmt ::= "guard" Expr ;
Stmt_Assert . Stmt ::= "assert" Expr ;

Jump_GoTo . Jump ::= "goto" OpenParen [BlockIdent] CloseParen ;
Jump_Unreachable . Jump ::= "unreachable" ;
Jump_Return . Jump ::= "return" OpenParen [Expr] CloseParen ;
Jump_ProcReturn. Jump ::= "return"  ;

LVar_Local . LVar ::= "var" LocalVar;
LVar_Global . LVar ::= GlobalVar;

separator nonempty LVar "," ;

separator Block ";" ;

rules StmtWithAttrib ::= Stmt AttribSet ;
terminator StmtWithAttrib ";";

rules JumpWithAttrib ::= Jump AttribSet ;

rules PhiExpr ::= BlockIdent "->" Var ;
separator PhiExpr "," ;

rules PhiAssign ::= LVar ":=" "phi" OpenParen [ PhiExpr ] CloseParen;
separator PhiAssign ",";


Block_NoPhi . Block ::= "block" BlockIdent AttribSet BeginList 
  [StmtWithAttrib] JumpWithAttrib ";"
  EndList ;

Block_Phi . Block ::= "block" BlockIdent AttribSet BeginList 
  OpenParen [PhiAssign] CloseParen ";"
  [StmtWithAttrib] JumpWithAttrib ";"
  EndList ;

rules AttrKeyValue ::= BIdent "=" Attr ;
separator AttrKeyValue ";";

AttribSet_Some . AttribSet ::= BeginRec [ AttrKeyValue ] Semicolons EndRec;
AttribSet_Empty . AttribSet ::= "" ;

separator Attr ";" ;

Attr_Map . Attr ::= BeginRec [ AttrKeyValue ] Semicolons EndRec ; 
Attr_List . Attr ::= BeginList [ Attr ] EndList; 
Attr_Lit . Attr ::= Value ; 
Attr_Expr . Attr ::= Expr; 
Attr_Str . Attr ::= Str ; 

rules Params ::=  LocalIdent ":" Type ;
separator Params "," ;

rules FunParams ::=  LocalIdent ":" Type | OpenParen LocalIdent ":" Type CloseParen ;
separator FunParams " " ;

{- EXPRESSIONS -}

Value_BV . Value ::=  BVVal;
Value_Int . Value ::= IntVal;
Value_True . Value ::= "true" ;
Value_False . Value ::= "false" ;

Expr_Literal . Expr ::= Value; 

Expr_Paren . Expr ::= OpenParen  Expr CloseParen; 

Expr_Local . Expr ::= LocalVar;
Expr_Global . Expr ::= GlobalVar;

-- quantifiers

rules LParen ::= LocalVar | OpenParen LocalVar CloseParen ;
separator LParen ",";

rules LambdaDef ::=  [LParen]  LambdaSep Expr ;
Expr_Forall . Expr ::= "forall" AttribSet   LambdaDef ;
Expr_Exists . Expr ::= "exists" AttribSet  LambdaDef ;
Expr_Lambda . Expr ::= "fun" AttribSet  LambdaDef ;
Expr_Old . Expr       ::= "old" OpenParen Expr CloseParen ;

-- uninterpreted functions
Expr_FunctionOp . Expr       ::= GlobalIdent OpenParen [Expr] CloseParen;
Expr_Apply . Expr       ::= Expr Expr;

-- binary expr

rules BinOp ::= BVBinOp | BVLogicalBinOp | BoolBinOp | IntLogicalBinOp | IntBinOp | EqOp ;
Expr_Binary . Expr       ::= BinOp OpenParen Expr "," Expr CloseParen ;
Expr_Assoc . Expr       ::= BoolBinOp OpenParen [Expr] CloseParen ;

rules UnOp ::= BVUnOp | "boolnot" | "intneg" | "booltobv1" | "gamma" | "classification";
Expr_Unary . Expr       ::= UnOp OpenParen Expr CloseParen ;

Expr_LoadBe . Expr ::= "load_be" OpenParen IntVal "," Expr "," Expr CloseParen ;
Expr_LoadLe . Expr ::= "load_le" OpenParen IntVal "," Expr "," Expr CloseParen ;

Expr_ZeroExtend . Expr ::= "zero_extend" OpenParen IntVal "," Expr CloseParen ;
Expr_SignExtend . Expr ::= "sign_extend" OpenParen IntVal "," Expr CloseParen ;
Expr_Extract    . Expr ::= "extract" OpenParen IntVal "," IntVal "," Expr CloseParen ;
Expr_Concat     . Expr ::= "bvconcat"  OpenParen [Expr]  CloseParen ;

CaseCase . Case ::= Expr "->" Expr  ;
CaseDefault . Case ::=  "_" "->" Expr ;
separator Case "|" ;

Expr_Match . Expr ::= "match" Expr "with" OpenParen [Case] CloseParen ;
Expr_Cases . Expr ::= "cases" OpenParen [Case] CloseParen ;

-- operators

rules EqOp ::= "eq" | "neq" ;
rules BVUnOp ::= "bvnot" | "bvneg" ;
rules BVBinOp ::= "bvand"|"bvor"|"bvadd"|"bvmul"|"bvudiv"|"bvurem"|"bvshl"|"bvlshr"|"bvnand"|"bvnor"
  |"bvxor"|"bvxnor"|"bvcomp"|"bvsub"|"bvsdiv"|"bvsrem"|"bvsmod"|"bvashr" ;
rules BVLogicalBinOp ::= "bvule" |  "bvugt" |  "bvuge" | "bvult" | "bvslt" |  "bvsle" |  "bvsgt" |  "bvsge" ;

rules IntBinOp ::= "intadd" | "intmul" | "intsub" | "intdiv" | "intmod"  ;
rules IntLogicalBinOp ::=  "intlt" | "intle" | "intgt" | "intge" ;
rules BoolBinOp ::=  "booland" | "boolor" | "boolimplies" ;


{- SPECIFICATION -}

rules RequireTok ::= "require" | "requires" ;
rules EnsureTok ::= "ensure" | "ensures" ;
rules RelyTok ::= "rely" | "relies";
rules GuarTok ::= "guarnatee" | "guarantees";

FunSpec_Require . FunSpec ::= RequireTok Expr;
FunSpec_Ensure . FunSpec ::= EnsureTok Expr;
FunSpec_Rely . FunSpec ::= RelyTok Expr;
FunSpec_Guar . FunSpec ::= GuarTok Expr;
FunSpec_Captures . FunSpec ::= "captures" [GlobalVar];
FunSpec_Modifies . FunSpec ::= "modifies" [GlobalVar];


VarSpec_Classification . VarSpec ::= "classification" Expr;
VarSpec_Empty . VarSpec ::= "";


FunSpec_Invariant . FunSpec ::= "invariant" BlockIdent Expr;

ProgSpec_Rely . ProgSpec ::= "rely" Expr;
ProgSpec_Guarantee . ProgSpec ::= "guarantee" Expr;

terminator FunSpec ";";

{- last semicolon terminates the prog definitino -}
separator ProgSpec ";";



