(* File generated by the BNF Converter (bnfc 2.9.6.1). *)

module SkelBasilIR = struct

open AbsBasilIR

type result = string

let failure x = failwith "Undefined case." (* x discarded *)

let rec transBVTYPE (x : bVTYPE) : result = match x with
    BVTYPE string -> failure x


and transINTTYPE (x : iNTTYPE) : result = match x with
    INTTYPE string -> failure x


and transBOOLTYPE (x : bOOLTYPE) : result = match x with
    BOOLTYPE string -> failure x


and transBIdent (x : bIdent) : result = match x with
    BIdent string -> failure x


and transLocalIdent (x : localIdent) : result = match x with
    LocalIdent string -> failure x


and transGlobalIdent (x : globalIdent) : result = match x with
    GlobalIdent string -> failure x


and transBlockIdent (x : blockIdent) : result = match x with
    BlockIdent string -> failure x


and transProcIdent (x : procIdent) : result = match x with
    ProcIdent string -> failure x


and transOpenParen (x : openParen) : result = match x with
    OpenParen string -> failure x


and transCloseParen (x : closeParen) : result = match x with
    CloseParen string -> failure x


and transBeginList (x : beginList) : result = match x with
    BeginList string -> failure x


and transEndList (x : endList) : result = match x with
    EndList string -> failure x


and transBeginRec (x : beginRec) : result = match x with
    BeginRec string -> failure x


and transEndRec (x : endRec) : result = match x with
    EndRec string -> failure x


and transStr (x : str) : result = match x with
    Str string -> failure x


and transIntegerHex (x : integerHex) : result = match x with
    IntegerHex string -> failure x


and transIntegerDec (x : integerDec) : result = match x with
    IntegerDec string -> failure x


and transModule (x : moduleT) : result = match x with
    Module1 decls -> failure x


and transLambdaSep (x : lambdaSep) : result = match x with
    LambdaSep1  -> failure x
  | LambdaSep2  -> failure x


and transSemicolons (x : semicolons) : result = match x with
    Semicolons_Empty  -> failure x
  | Semicolons_Some semicolons -> failure x


and transVarModifiers (x : varModifiers) : result = match x with
    Shared  -> failure x
  | Observable  -> failure x


and transDecl (x : decl) : result = match x with
    Decl_Axiom (globalident, attribset, expr) -> failure x
  | Decl_Mem (varmodifierss, globalident, type', varspec) -> failure x
  | Decl_Var (varmodifierss, globalident, type', varspec) -> failure x
  | Decl_UninterpFun (globalident, attribset, type') -> failure x
  | Decl_Fun (globalident, attribset, type', expr) -> failure x
  | Decl_FunNoType (globalident, attribset, expr) -> failure x
  | Decl_ProgEmpty (procident, attribset) -> failure x
  | Decl_ProgWithSpec (procident, attribset, progspecs) -> failure x
  | Decl_Proc (procident, openparen0, paramss1, closeparen2, openparen, paramss, closeparen, attribset, funspecs, procdef) -> failure x


and transProcDef (x : procDef) : result = match x with
    ProcDef_Empty  -> failure x
  | ProcDef_Some (beginlist, blocks, endlist) -> failure x


and transIntType (x : intType) : result = match x with
    IntType1 inttype -> failure x


and transBoolType (x : boolType) : result = match x with
    BoolType1 booltype -> failure x


and transMapType (x : mapType) : result = match x with
    MapType1 (type'0, type') -> failure x


and transBVType (x : bVType) : result = match x with
    BVType1 bvtype -> failure x


and transType (x : typeT) : result = match x with
    TypeIntType inttype -> failure x
  | TypeBoolType booltype -> failure x
  | TypeMapType maptype -> failure x
  | TypeBVType bvtype -> failure x
  | Type1 (openparen, type', closeparen) -> failure x


and transIntVal (x : intVal) : result = match x with
    IntVal_Hex integerhex -> failure x
  | IntVal_Dec integerdec -> failure x


and transBVVal (x : bVVal) : result = match x with
    BVVal1 (intval, bvtype) -> failure x


and transEndian (x : endian) : result = match x with
    Endian_Little  -> failure x
  | Endian_Big  -> failure x


and transAssignment (x : assignment) : result = match x with
    Assignment1 (lvar, expr) -> failure x


and transStmt (x : stmt) : result = match x with
    Stmt_Nop  -> failure x
  | Stmt_SingleAssign assignment -> failure x
  | Stmt_MemAssign (lvar, expr) -> failure x
  | Stmt_ScalarStore (lvar, expr) -> failure x
  | Stmt_ScalarLoad (lvar, var) -> failure x
  | Stmt_MultiAssign (openparen, assignments, closeparen) -> failure x
  | Stmt_Load (lvar, endian, globalident, expr, intval) -> failure x
  | Stmt_Store (endian, globalident, expr0, expr, intval) -> failure x
  | Stmt_Load_Var (lvar, endian, var, expr, intval) -> failure x
  | Stmt_Store_Var (lvar, endian, var, expr0, expr, intval) -> failure x
  | Stmt_DirectCall (lvars, procident, openparen, callparams, closeparen) -> failure x
  | Stmt_IndirectCall expr -> failure x
  | Stmt_Assume expr -> failure x
  | Stmt_Guard expr -> failure x
  | Stmt_Assert expr -> failure x


and transLocalVar (x : localVar) : result = match x with
    LocalTyped (localident, type') -> failure x
  | LocalUntyped localident -> failure x


and transGlobalVar (x : globalVar) : result = match x with
    GlobalTyped (globalident, type') -> failure x
  | GlobalUntyped globalident -> failure x


and transVar (x : var) : result = match x with
    VarLocalVar localvar -> failure x
  | VarGlobalVar globalvar -> failure x


and transNamedCallReturn (x : namedCallReturn) : result = match x with
    NamedCallReturn1 (lvar, localident) -> failure x


and transLVars (x : lVars) : result = match x with
    LVars_Empty  -> failure x
  | LVars_LocalList (openparen, localvars, closeparen) -> failure x
  | LVars_List (openparen, lvars, closeparen) -> failure x
  | NamedLVars_List (openparen, namedcallreturns, closeparen) -> failure x


and transNamedCallArg (x : namedCallArg) : result = match x with
    NamedCallArg1 (localident, expr) -> failure x


and transCallParams (x : callParams) : result = match x with
    CallParams_Exprs exprs -> failure x
  | CallParams_Named namedcallargs -> failure x


and transJump (x : jump) : result = match x with
    Jump_GoTo (openparen, blockidents, closeparen) -> failure x
  | Jump_Unreachable  -> failure x
  | Jump_Return (openparen, exprs, closeparen) -> failure x
  | Jump_ProcReturn  -> failure x


and transLVar (x : lVar) : result = match x with
    LVar_Local localvar -> failure x
  | LVar_Global globalvar -> failure x


and transStmtWithAttrib (x : stmtWithAttrib) : result = match x with
    StmtWithAttrib1 (stmt, attribset) -> failure x


and transJumpWithAttrib (x : jumpWithAttrib) : result = match x with
    JumpWithAttrib1 (jump, attribset) -> failure x


and transPhiExpr (x : phiExpr) : result = match x with
    PhiExpr1 (blockident, var) -> failure x


and transPhiAssign (x : phiAssign) : result = match x with
    PhiAssign1 (lvar, openparen, phiexprs, closeparen) -> failure x


and transBlock (x : block) : result = match x with
    Block_NoPhi (blockident, attribset, beginlist, stmtwithattribs, jumpwithattrib, endlist) -> failure x
  | Block_Phi (blockident, attribset, beginlist, openparen, phiassigns, closeparen, stmtwithattribs, jumpwithattrib, endlist) -> failure x


and transAttrKeyValue (x : attrKeyValue) : result = match x with
    AttrKeyValue1 (bident, attr) -> failure x


and transAttribSet (x : attribSet) : result = match x with
    AttribSet_Some (beginrec, attrkeyvalues, semicolons, endrec) -> failure x
  | AttribSet_Empty  -> failure x


and transAttr (x : attr) : result = match x with
    Attr_Map (beginrec, attrkeyvalues, semicolons, endrec) -> failure x
  | Attr_List (beginlist, attrs, endlist) -> failure x
  | Attr_Lit value -> failure x
  | Attr_Expr expr -> failure x
  | Attr_Str str -> failure x


and transParams (x : params) : result = match x with
    Params1 (localident, type') -> failure x


and transFunParams (x : funParams) : result = match x with
    FunParams1 (localident, type') -> failure x
  | FunParams2 (openparen, localident, type', closeparen) -> failure x


and transValue (x : value) : result = match x with
    Value_BV bvval -> failure x
  | Value_Int intval -> failure x
  | Value_True  -> failure x
  | Value_False  -> failure x


and transExpr (x : expr) : result = match x with
    Expr_Literal value -> failure x
  | Expr_Paren (openparen, expr, closeparen) -> failure x
  | Expr_Local localvar -> failure x
  | Expr_Global globalvar -> failure x
  | Expr_Forall (attribset, lambdadef) -> failure x
  | Expr_Exists (attribset, lambdadef) -> failure x
  | Expr_Lambda (attribset, lambdadef) -> failure x
  | Expr_Old (openparen, expr, closeparen) -> failure x
  | Expr_FunctionOp (globalident, openparen, exprs, closeparen) -> failure x
  | Expr_Apply (expr0, expr) -> failure x
  | Expr_Binary (binop, openparen, expr0, expr, closeparen) -> failure x
  | Expr_Assoc (boolbinop, openparen, exprs, closeparen) -> failure x
  | Expr_Unary (unop, openparen, expr, closeparen) -> failure x
  | Expr_LoadBe (openparen, intval, expr0, expr, closeparen) -> failure x
  | Expr_LoadLe (openparen, intval, expr0, expr, closeparen) -> failure x
  | Expr_ZeroExtend (openparen, intval, expr, closeparen) -> failure x
  | Expr_SignExtend (openparen, intval, expr, closeparen) -> failure x
  | Expr_Extract (openparen, intval0, intval, expr, closeparen) -> failure x
  | Expr_Concat (openparen, exprs, closeparen) -> failure x
  | Expr_Match (expr, openparen, cases, closeparen) -> failure x
  | Expr_Cases (openparen, cases, closeparen) -> failure x


and transLParen (x : lParen) : result = match x with
    LParenLocalVar localvar -> failure x
  | LParen1 (openparen, localvar, closeparen) -> failure x


and transLambdaDef (x : lambdaDef) : result = match x with
    LambdaDef1 (lparens, lambdasep, expr) -> failure x


and transBinOp (x : binOp) : result = match x with
    BinOpBVBinOp bvbinop -> failure x
  | BinOpBVLogicalBinOp bvlogicalbinop -> failure x
  | BinOpBoolBinOp boolbinop -> failure x
  | BinOpIntLogicalBinOp intlogicalbinop -> failure x
  | BinOpIntBinOp intbinop -> failure x
  | BinOpEqOp eqop -> failure x


and transUnOp (x : unOp) : result = match x with
    UnOpBVUnOp bvunop -> failure x
  | UnOp_boolnot  -> failure x
  | UnOp_intneg  -> failure x
  | UnOp_booltobv1  -> failure x
  | UnOp_gamma  -> failure x
  | UnOp_classification  -> failure x


and transCase (x : case) : result = match x with
    CaseCase (expr0, expr) -> failure x
  | CaseDefault expr -> failure x


and transEqOp (x : eqOp) : result = match x with
    EqOp_eq  -> failure x
  | EqOp_neq  -> failure x


and transBVUnOp (x : bVUnOp) : result = match x with
    BVUnOp_bvnot  -> failure x
  | BVUnOp_bvneg  -> failure x


and transBVBinOp (x : bVBinOp) : result = match x with
    BVBinOp_bvand  -> failure x
  | BVBinOp_bvor  -> failure x
  | BVBinOp_bvadd  -> failure x
  | BVBinOp_bvmul  -> failure x
  | BVBinOp_bvudiv  -> failure x
  | BVBinOp_bvurem  -> failure x
  | BVBinOp_bvshl  -> failure x
  | BVBinOp_bvlshr  -> failure x
  | BVBinOp_bvnand  -> failure x
  | BVBinOp_bvnor  -> failure x
  | BVBinOp_bvxor  -> failure x
  | BVBinOp_bvxnor  -> failure x
  | BVBinOp_bvcomp  -> failure x
  | BVBinOp_bvsub  -> failure x
  | BVBinOp_bvsdiv  -> failure x
  | BVBinOp_bvsrem  -> failure x
  | BVBinOp_bvsmod  -> failure x
  | BVBinOp_bvashr  -> failure x


and transBVLogicalBinOp (x : bVLogicalBinOp) : result = match x with
    BVLogicalBinOp_bvule  -> failure x
  | BVLogicalBinOp_bvugt  -> failure x
  | BVLogicalBinOp_bvuge  -> failure x
  | BVLogicalBinOp_bvult  -> failure x
  | BVLogicalBinOp_bvslt  -> failure x
  | BVLogicalBinOp_bvsle  -> failure x
  | BVLogicalBinOp_bvsgt  -> failure x
  | BVLogicalBinOp_bvsge  -> failure x


and transIntBinOp (x : intBinOp) : result = match x with
    IntBinOp_intadd  -> failure x
  | IntBinOp_intmul  -> failure x
  | IntBinOp_intsub  -> failure x
  | IntBinOp_intdiv  -> failure x
  | IntBinOp_intmod  -> failure x


and transIntLogicalBinOp (x : intLogicalBinOp) : result = match x with
    IntLogicalBinOp_intlt  -> failure x
  | IntLogicalBinOp_intle  -> failure x
  | IntLogicalBinOp_intgt  -> failure x
  | IntLogicalBinOp_intge  -> failure x


and transBoolBinOp (x : boolBinOp) : result = match x with
    BoolBinOp_booland  -> failure x
  | BoolBinOp_boolor  -> failure x
  | BoolBinOp_boolimplies  -> failure x


and transRequireTok (x : requireTok) : result = match x with
    RequireTok_require  -> failure x
  | RequireTok_requires  -> failure x


and transEnsureTok (x : ensureTok) : result = match x with
    EnsureTok_ensure  -> failure x
  | EnsureTok_ensures  -> failure x


and transRelyTok (x : relyTok) : result = match x with
    RelyTok_rely  -> failure x
  | RelyTok_relies  -> failure x


and transGuarTok (x : guarTok) : result = match x with
    GuarTok_guarnatee  -> failure x
  | GuarTok_guarantees  -> failure x


and transFunSpec (x : funSpec) : result = match x with
    FunSpec_Require (requiretok, expr) -> failure x
  | FunSpec_Ensure (ensuretok, expr) -> failure x
  | FunSpec_Rely (relytok, expr) -> failure x
  | FunSpec_Guar (guartok, expr) -> failure x
  | FunSpec_Captures globalvars -> failure x
  | FunSpec_Modifies globalvars -> failure x
  | FunSpec_Invariant (blockident, expr) -> failure x


and transVarSpec (x : varSpec) : result = match x with
    VarSpec_Classification expr -> failure x
  | VarSpec_Empty  -> failure x


and transProgSpec (x : progSpec) : result = match x with
    ProgSpec_Rely expr -> failure x
  | ProgSpec_Guarantee expr -> failure x



end
