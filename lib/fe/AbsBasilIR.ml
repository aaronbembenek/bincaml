(* File generated by the BNF Converter (bnfc 2.9.6.1). *)

type bVTYPE = BVTYPE of ((int * int) * string)
and iNTTYPE = INTTYPE of ((int * int) * string)
and bOOLTYPE = BOOLTYPE of ((int * int) * string)
and bIdent = BIdent of ((int * int) * string)
and localIdent = LocalIdent of ((int * int) * string)
and globalIdent = GlobalIdent of ((int * int) * string)
and blockIdent = BlockIdent of ((int * int) * string)
and procIdent = ProcIdent of ((int * int) * string)
and openParen = OpenParen of ((int * int) * string)
and closeParen = CloseParen of ((int * int) * string)
and beginList = BeginList of ((int * int) * string)
and endList = EndList of ((int * int) * string)
and beginRec = BeginRec of ((int * int) * string)
and endRec = EndRec of ((int * int) * string)
and str = Str of string
and integerHex = IntegerHex of ((int * int) * string)
and integerDec = IntegerDec of ((int * int) * string)
and moduleT =
   Module1 of decl list

and lambdaSep =
   LambdaSep1
 | LambdaSep2

and semicolons =
   Semicolons_Empty
 | Semicolons_Some of semicolons

and varModifiers =
   Shared
 | Observable

and decl =
   Decl_Axiom of globalIdent * attribSet * expr
 | Decl_Mem of varModifiers list * globalIdent * typeT * varSpec
 | Decl_Var of varModifiers list * globalIdent * typeT * varSpec
 | Decl_UninterpFun of globalIdent * attribSet * typeT
 | Decl_Fun of globalIdent * attribSet * typeT * expr
 | Decl_FunNoType of globalIdent * attribSet * expr
 | Decl_ProgEmpty of procIdent * attribSet
 | Decl_ProgWithSpec of procIdent * attribSet * progSpec list
 | Decl_Proc of procIdent * openParen * params list * closeParen * openParen * params list * closeParen * attribSet * funSpec list * procDef

and procDef =
   ProcDef_Empty
 | ProcDef_Some of beginList * block list * endList

and intType =
   IntType1 of iNTTYPE

and boolType =
   BoolType1 of bOOLTYPE

and mapType =
   MapType1 of typeT * typeT

and bVType =
   BVType1 of bVTYPE

and typeT =
   TypeIntType of intType
 | TypeBoolType of boolType
 | TypeMapType of mapType
 | TypeBVType of bVType
 | Type1 of openParen * typeT * closeParen

and intVal =
   IntVal_Hex of integerHex
 | IntVal_Dec of integerDec

and bVVal =
   BVVal1 of intVal * bVType

and endian =
   Endian_Little
 | Endian_Big

and assignment =
   Assignment1 of lVar * expr

and stmt =
   Stmt_Nop
 | Stmt_SingleAssign of assignment
 | Stmt_MemAssign of lVar * expr
 | Stmt_ScalarStore of lVar * expr
 | Stmt_ScalarLoad of lVar * var
 | Stmt_MultiAssign of openParen * assignment list * closeParen
 | Stmt_Load of lVar * endian * globalIdent * expr * intVal
 | Stmt_Store of endian * globalIdent * expr * expr * intVal
 | Stmt_Load_Var of lVar * endian * var * expr * intVal
 | Stmt_Store_Var of lVar * endian * var * expr * expr * intVal
 | Stmt_DirectCall of lVars * procIdent * openParen * callParams * closeParen
 | Stmt_IndirectCall of expr
 | Stmt_Assume of expr
 | Stmt_Guard of expr
 | Stmt_Assert of expr

and localVar =
   LocalTyped of localIdent * typeT
 | LocalUntyped of localIdent

and globalVar =
   GlobalTyped of globalIdent * typeT
 | GlobalUntyped of globalIdent

and var =
   VarLocalVar of localVar
 | VarGlobalVar of globalVar

and namedCallReturn =
   NamedCallReturn1 of lVar * localIdent

and lVars =
   LVars_Empty
 | LVars_LocalList of openParen * localVar list * closeParen
 | LVars_List of openParen * lVar list * closeParen
 | NamedLVars_List of openParen * namedCallReturn list * closeParen

and namedCallArg =
   NamedCallArg1 of localIdent * expr

and callParams =
   CallParams_Exprs of expr list
 | CallParams_Named of namedCallArg list

and jump =
   Jump_GoTo of openParen * blockIdent list * closeParen
 | Jump_Unreachable
 | Jump_Return of openParen * expr list * closeParen
 | Jump_ProcReturn

and lVar =
   LVar_Local of localVar
 | LVar_Global of globalVar

and stmtWithAttrib =
   StmtWithAttrib1 of stmt * attribSet

and jumpWithAttrib =
   JumpWithAttrib1 of jump * attribSet

and phiExpr =
   PhiExpr1 of blockIdent * var

and phiAssign =
   PhiAssign1 of lVar * openParen * phiExpr list * closeParen

and block =
   Block_NoPhi of blockIdent * attribSet * beginList * stmtWithAttrib list * jumpWithAttrib * endList
 | Block_Phi of blockIdent * attribSet * beginList * openParen * phiAssign list * closeParen * stmtWithAttrib list * jumpWithAttrib * endList

and attrKeyValue =
   AttrKeyValue1 of bIdent * attr

and attribSet =
   AttribSet_Some of beginRec * attrKeyValue list * semicolons * endRec
 | AttribSet_Empty

and attr =
   Attr_Map of beginRec * attrKeyValue list * semicolons * endRec
 | Attr_List of beginList * attr list * endList
 | Attr_Lit of value
 | Attr_Expr of expr
 | Attr_Str of str

and params =
   Params1 of localIdent * typeT

and funParams =
   FunParams1 of localIdent * typeT
 | FunParams2 of openParen * localIdent * typeT * closeParen

and value =
   Value_BV of bVVal
 | Value_Int of intVal
 | Value_True
 | Value_False

and expr =
   Expr_Literal of value
 | Expr_Paren of openParen * expr * closeParen
 | Expr_Local of localVar
 | Expr_Global of globalVar
 | Expr_Forall of attribSet * lambdaDef
 | Expr_Exists of attribSet * lambdaDef
 | Expr_Lambda of attribSet * lambdaDef
 | Expr_Old of openParen * expr * closeParen
 | Expr_FunctionOp of globalIdent * openParen * expr list * closeParen
 | Expr_Apply of expr * expr
 | Expr_Binary of binOp * openParen * expr * expr * closeParen
 | Expr_Assoc of boolBinOp * openParen * expr list * closeParen
 | Expr_Unary of unOp * openParen * expr * closeParen
 | Expr_LoadBe of openParen * intVal * expr * expr * closeParen
 | Expr_LoadLe of openParen * intVal * expr * expr * closeParen
 | Expr_ZeroExtend of openParen * intVal * expr * closeParen
 | Expr_SignExtend of openParen * intVal * expr * closeParen
 | Expr_Extract of openParen * intVal * intVal * expr * closeParen
 | Expr_Concat of openParen * expr list * closeParen
 | Expr_Match of expr * openParen * case list * closeParen
 | Expr_Cases of openParen * case list * closeParen

and lParen =
   LParenLocalVar of localVar
 | LParen1 of openParen * localVar * closeParen

and lambdaDef =
   LambdaDef1 of lParen list * lambdaSep * expr

and binOp =
   BinOpBVBinOp of bVBinOp
 | BinOpBVLogicalBinOp of bVLogicalBinOp
 | BinOpBoolBinOp of boolBinOp
 | BinOpIntLogicalBinOp of intLogicalBinOp
 | BinOpIntBinOp of intBinOp
 | BinOpEqOp of eqOp

and unOp =
   UnOpBVUnOp of bVUnOp
 | UnOp_boolnot
 | UnOp_intneg
 | UnOp_booltobv1
 | UnOp_gamma
 | UnOp_classification

and case =
   CaseCase of expr * expr
 | CaseDefault of expr

and eqOp =
   EqOp_eq
 | EqOp_neq

and bVUnOp =
   BVUnOp_bvnot
 | BVUnOp_bvneg

and bVBinOp =
   BVBinOp_bvand
 | BVBinOp_bvor
 | BVBinOp_bvadd
 | BVBinOp_bvmul
 | BVBinOp_bvudiv
 | BVBinOp_bvurem
 | BVBinOp_bvshl
 | BVBinOp_bvlshr
 | BVBinOp_bvnand
 | BVBinOp_bvnor
 | BVBinOp_bvxor
 | BVBinOp_bvxnor
 | BVBinOp_bvcomp
 | BVBinOp_bvsub
 | BVBinOp_bvsdiv
 | BVBinOp_bvsrem
 | BVBinOp_bvsmod
 | BVBinOp_bvashr

and bVLogicalBinOp =
   BVLogicalBinOp_bvule
 | BVLogicalBinOp_bvugt
 | BVLogicalBinOp_bvuge
 | BVLogicalBinOp_bvult
 | BVLogicalBinOp_bvslt
 | BVLogicalBinOp_bvsle
 | BVLogicalBinOp_bvsgt
 | BVLogicalBinOp_bvsge

and intBinOp =
   IntBinOp_intadd
 | IntBinOp_intmul
 | IntBinOp_intsub
 | IntBinOp_intdiv
 | IntBinOp_intmod

and intLogicalBinOp =
   IntLogicalBinOp_intlt
 | IntLogicalBinOp_intle
 | IntLogicalBinOp_intgt
 | IntLogicalBinOp_intge

and boolBinOp =
   BoolBinOp_booland
 | BoolBinOp_boolor
 | BoolBinOp_boolimplies

and requireTok =
   RequireTok_require
 | RequireTok_requires

and ensureTok =
   EnsureTok_ensure
 | EnsureTok_ensures

and relyTok =
   RelyTok_rely
 | RelyTok_relies

and guarTok =
   GuarTok_guarnatee
 | GuarTok_guarantees

and funSpec =
   FunSpec_Require of requireTok * expr
 | FunSpec_Ensure of ensureTok * expr
 | FunSpec_Rely of relyTok * expr
 | FunSpec_Guar of guarTok * expr
 | FunSpec_Captures of globalVar list
 | FunSpec_Modifies of globalVar list
 | FunSpec_Invariant of blockIdent * expr

and varSpec =
   VarSpec_Classification of expr
 | VarSpec_Empty

and progSpec =
   ProgSpec_Rely of expr
 | ProgSpec_Guarantee of expr

