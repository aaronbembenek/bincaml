/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/* Parser definition for use with menhir */

%{
open AbsBasilIR
open Lexing
%}

%token KW_shared KW_observable KW_axiom KW_memory KW_var KW_val KW_let KW_prog KW_entry KW_proc KW_le KW_be KW_nop KW_store KW_load KW_call KW_indirect KW_assume KW_guard KW_assert KW_goto KW_unreachable KW_return KW_phi KW_block KW_true KW_false KW_forall KW_exists KW_fun KW_old KW_boolnot KW_intneg KW_booltobv1 KW_gamma KW_classification KW_load_be KW_load_le KW_zero_extend KW_sign_extend KW_extract KW_bvconcat KW_match KW_with KW_cases KW_eq KW_neq KW_bvnot KW_bvneg KW_bvand KW_bvor KW_bvadd KW_bvmul KW_bvudiv KW_bvurem KW_bvshl KW_bvlshr KW_bvnand KW_bvnor KW_bvxor KW_bvxnor KW_bvcomp KW_bvsub KW_bvsdiv KW_bvsrem KW_bvsmod KW_bvashr KW_bvule KW_bvugt KW_bvuge KW_bvult KW_bvslt KW_bvsle KW_bvsgt KW_bvsge KW_intadd KW_intmul KW_intsub KW_intdiv KW_intmod KW_intlt KW_intle KW_intgt KW_intge KW_booland KW_boolor KW_boolimplies KW_require KW_requires KW_ensure KW_ensures KW_rely KW_relies KW_guarnatee KW_guarantees KW_captures KW_modifies KW_invariant KW_guarantee

%token SYMB1 /* ; */
%token SYMB2 /* , */
%token SYMB3 /* -> */
%token SYMB4 /* :: */
%token SYMB5 /* : */
%token SYMB6 /* = */
%token SYMB7 /* := */
%token SYMB8 /* mem:= */
%token SYMB9 /* _ */
%token SYMB10 /* | */

%token TOK_EOF
%token <string> TOK_Ident
%token <char>   TOK_Char
%token <float>  TOK_Double
%token <int>    TOK_Integer
%token <string> TOK_String
%token <(int * int) * string> TOK_BVTYPE
%token <(int * int) * string> TOK_INTTYPE
%token <(int * int) * string> TOK_BOOLTYPE
%token <(int * int) * string> TOK_BIdent
%token <(int * int) * string> TOK_LocalIdent
%token <(int * int) * string> TOK_GlobalIdent
%token <(int * int) * string> TOK_BlockIdent
%token <(int * int) * string> TOK_ProcIdent
%token <(int * int) * string> TOK_OpenParen
%token <(int * int) * string> TOK_CloseParen
%token <(int * int) * string> TOK_BeginList
%token <(int * int) * string> TOK_EndList
%token <(int * int) * string> TOK_BeginRec
%token <(int * int) * string> TOK_EndRec
%token <string>               TOK_Str
%token <(int * int) * string> TOK_IntegerHex
%token <(int * int) * string> TOK_IntegerDec

%start pModuleT pDecl_list pBlockIdent_list pLambdaSep pSemicolons pVarModifiers pVarModifiers_list pDecl pTypeT_list pProcDef pIntType pBoolType pMapType pBVType pTypeT pExpr_list pIntVal pBVVal pEndian pAssignment pStmt pAssignment_list pLocalVar pGlobalVar pLocalVar_list pVar pGlobalVar_list pNamedCallReturn pNamedCallReturn_list pLVars pNamedCallArg pNamedCallArg_list pCallParams pJump pLVar pLVar_list pBlock_list pStmtWithAttrib pStmtWithAttrib_list pJumpWithAttrib pPhiExpr pPhiExpr_list pPhiAssign pPhiAssign_list pBlock pAttrKeyValue pAttrKeyValue_list pAttribSet pAttr_list pAttr pParams pParams_list pFunParams pFunParams_list pValue pExpr pLParen pLParen_list pLambdaDef pBinOp pUnOp pCase pCase_list pEqOp pBVUnOp pBVBinOp pBVLogicalBinOp pIntBinOp pIntLogicalBinOp pBoolBinOp pRequireTok pEnsureTok pRelyTok pGuarTok pFunSpec pVarSpec pProgSpec pFunSpec_list pProgSpec_list
%type <AbsBasilIR.moduleT> pModuleT
%type <AbsBasilIR.decl list> pDecl_list
%type <AbsBasilIR.blockIdent list> pBlockIdent_list
%type <AbsBasilIR.lambdaSep> pLambdaSep
%type <AbsBasilIR.semicolons> pSemicolons
%type <AbsBasilIR.varModifiers> pVarModifiers
%type <AbsBasilIR.varModifiers list> pVarModifiers_list
%type <AbsBasilIR.decl> pDecl
%type <AbsBasilIR.typeT list> pTypeT_list
%type <AbsBasilIR.procDef> pProcDef
%type <AbsBasilIR.intType> pIntType
%type <AbsBasilIR.boolType> pBoolType
%type <AbsBasilIR.mapType> pMapType
%type <AbsBasilIR.bVType> pBVType
%type <AbsBasilIR.typeT> pTypeT
%type <AbsBasilIR.expr list> pExpr_list
%type <AbsBasilIR.intVal> pIntVal
%type <AbsBasilIR.bVVal> pBVVal
%type <AbsBasilIR.endian> pEndian
%type <AbsBasilIR.assignment> pAssignment
%type <AbsBasilIR.stmt> pStmt
%type <AbsBasilIR.assignment list> pAssignment_list
%type <AbsBasilIR.localVar> pLocalVar
%type <AbsBasilIR.globalVar> pGlobalVar
%type <AbsBasilIR.localVar list> pLocalVar_list
%type <AbsBasilIR.var> pVar
%type <AbsBasilIR.globalVar list> pGlobalVar_list
%type <AbsBasilIR.namedCallReturn> pNamedCallReturn
%type <AbsBasilIR.namedCallReturn list> pNamedCallReturn_list
%type <AbsBasilIR.lVars> pLVars
%type <AbsBasilIR.namedCallArg> pNamedCallArg
%type <AbsBasilIR.namedCallArg list> pNamedCallArg_list
%type <AbsBasilIR.callParams> pCallParams
%type <AbsBasilIR.jump> pJump
%type <AbsBasilIR.lVar> pLVar
%type <AbsBasilIR.lVar list> pLVar_list
%type <AbsBasilIR.block list> pBlock_list
%type <AbsBasilIR.stmtWithAttrib> pStmtWithAttrib
%type <AbsBasilIR.stmtWithAttrib list> pStmtWithAttrib_list
%type <AbsBasilIR.jumpWithAttrib> pJumpWithAttrib
%type <AbsBasilIR.phiExpr> pPhiExpr
%type <AbsBasilIR.phiExpr list> pPhiExpr_list
%type <AbsBasilIR.phiAssign> pPhiAssign
%type <AbsBasilIR.phiAssign list> pPhiAssign_list
%type <AbsBasilIR.block> pBlock
%type <AbsBasilIR.attrKeyValue> pAttrKeyValue
%type <AbsBasilIR.attrKeyValue list> pAttrKeyValue_list
%type <AbsBasilIR.attribSet> pAttribSet
%type <AbsBasilIR.attr list> pAttr_list
%type <AbsBasilIR.attr> pAttr
%type <AbsBasilIR.params> pParams
%type <AbsBasilIR.params list> pParams_list
%type <AbsBasilIR.funParams> pFunParams
%type <AbsBasilIR.funParams list> pFunParams_list
%type <AbsBasilIR.value> pValue
%type <AbsBasilIR.expr> pExpr
%type <AbsBasilIR.lParen> pLParen
%type <AbsBasilIR.lParen list> pLParen_list
%type <AbsBasilIR.lambdaDef> pLambdaDef
%type <AbsBasilIR.binOp> pBinOp
%type <AbsBasilIR.unOp> pUnOp
%type <AbsBasilIR.case> pCase
%type <AbsBasilIR.case list> pCase_list
%type <AbsBasilIR.eqOp> pEqOp
%type <AbsBasilIR.bVUnOp> pBVUnOp
%type <AbsBasilIR.bVBinOp> pBVBinOp
%type <AbsBasilIR.bVLogicalBinOp> pBVLogicalBinOp
%type <AbsBasilIR.intBinOp> pIntBinOp
%type <AbsBasilIR.intLogicalBinOp> pIntLogicalBinOp
%type <AbsBasilIR.boolBinOp> pBoolBinOp
%type <AbsBasilIR.requireTok> pRequireTok
%type <AbsBasilIR.ensureTok> pEnsureTok
%type <AbsBasilIR.relyTok> pRelyTok
%type <AbsBasilIR.guarTok> pGuarTok
%type <AbsBasilIR.funSpec> pFunSpec
%type <AbsBasilIR.varSpec> pVarSpec
%type <AbsBasilIR.progSpec> pProgSpec
%type <AbsBasilIR.funSpec list> pFunSpec_list
%type <AbsBasilIR.progSpec list> pProgSpec_list

%type <AbsBasilIR.moduleT> moduleT
%type <AbsBasilIR.decl list> decl_list
%type <AbsBasilIR.blockIdent list> blockIdent_list
%type <AbsBasilIR.lambdaSep> lambdaSep
%type <AbsBasilIR.semicolons> semicolons
%type <AbsBasilIR.varModifiers> varModifiers
%type <AbsBasilIR.varModifiers list> varModifiers_list
%type <AbsBasilIR.decl> decl
%type <AbsBasilIR.typeT list> typeT_list
%type <AbsBasilIR.procDef> procDef
%type <AbsBasilIR.intType> intType
%type <AbsBasilIR.boolType> boolType
%type <AbsBasilIR.mapType> mapType
%type <AbsBasilIR.bVType> bVType
%type <AbsBasilIR.typeT> typeT
%type <AbsBasilIR.expr list> expr_list
%type <AbsBasilIR.intVal> intVal
%type <AbsBasilIR.bVVal> bVVal
%type <AbsBasilIR.endian> endian
%type <AbsBasilIR.assignment> assignment
%type <AbsBasilIR.stmt> stmt
%type <AbsBasilIR.assignment list> assignment_list
%type <AbsBasilIR.localVar> localVar
%type <AbsBasilIR.globalVar> globalVar
%type <AbsBasilIR.localVar list> localVar_list
%type <AbsBasilIR.var> var
%type <AbsBasilIR.globalVar list> globalVar_list
%type <AbsBasilIR.namedCallReturn> namedCallReturn
%type <AbsBasilIR.namedCallReturn list> namedCallReturn_list
%type <AbsBasilIR.lVars> lVars
%type <AbsBasilIR.namedCallArg> namedCallArg
%type <AbsBasilIR.namedCallArg list> namedCallArg_list
%type <AbsBasilIR.callParams> callParams
%type <AbsBasilIR.jump> jump
%type <AbsBasilIR.lVar> lVar
%type <AbsBasilIR.lVar list> lVar_list
%type <AbsBasilIR.block list> block_list
%type <AbsBasilIR.stmtWithAttrib> stmtWithAttrib
%type <AbsBasilIR.stmtWithAttrib list> stmtWithAttrib_list
%type <AbsBasilIR.jumpWithAttrib> jumpWithAttrib
%type <AbsBasilIR.phiExpr> phiExpr
%type <AbsBasilIR.phiExpr list> phiExpr_list
%type <AbsBasilIR.phiAssign> phiAssign
%type <AbsBasilIR.phiAssign list> phiAssign_list
%type <AbsBasilIR.block> block
%type <AbsBasilIR.attrKeyValue> attrKeyValue
%type <AbsBasilIR.attrKeyValue list> attrKeyValue_list
%type <AbsBasilIR.attribSet> attribSet
%type <AbsBasilIR.attr list> attr_list
%type <AbsBasilIR.attr> attr
%type <AbsBasilIR.params> params
%type <AbsBasilIR.params list> params_list
%type <AbsBasilIR.funParams> funParams
%type <AbsBasilIR.funParams list> funParams_list
%type <AbsBasilIR.value> value
%type <AbsBasilIR.expr> expr
%type <AbsBasilIR.lParen> lParen
%type <AbsBasilIR.lParen list> lParen_list
%type <AbsBasilIR.lambdaDef> lambdaDef
%type <AbsBasilIR.binOp> binOp
%type <AbsBasilIR.unOp> unOp
%type <AbsBasilIR.case> case
%type <AbsBasilIR.case list> case_list
%type <AbsBasilIR.eqOp> eqOp
%type <AbsBasilIR.bVUnOp> bVUnOp
%type <AbsBasilIR.bVBinOp> bVBinOp
%type <AbsBasilIR.bVLogicalBinOp> bVLogicalBinOp
%type <AbsBasilIR.intBinOp> intBinOp
%type <AbsBasilIR.intLogicalBinOp> intLogicalBinOp
%type <AbsBasilIR.boolBinOp> boolBinOp
%type <AbsBasilIR.requireTok> requireTok
%type <AbsBasilIR.ensureTok> ensureTok
%type <AbsBasilIR.relyTok> relyTok
%type <AbsBasilIR.guarTok> guarTok
%type <AbsBasilIR.funSpec> funSpec
%type <AbsBasilIR.varSpec> varSpec
%type <AbsBasilIR.progSpec> progSpec
%type <AbsBasilIR.funSpec list> funSpec_list
%type <AbsBasilIR.progSpec list> progSpec_list

%type <AbsBasilIR.bVTYPE> bVTYPE
%type <AbsBasilIR.iNTTYPE> iNTTYPE
%type <AbsBasilIR.bOOLTYPE> bOOLTYPE
%type <AbsBasilIR.bIdent> bIdent
%type <AbsBasilIR.localIdent> localIdent
%type <AbsBasilIR.globalIdent> globalIdent
%type <AbsBasilIR.blockIdent> blockIdent
%type <AbsBasilIR.procIdent> procIdent
%type <AbsBasilIR.openParen> openParen
%type <AbsBasilIR.closeParen> closeParen
%type <AbsBasilIR.beginList> beginList
%type <AbsBasilIR.endList> endList
%type <AbsBasilIR.beginRec> beginRec
%type <AbsBasilIR.endRec> endRec
%type <AbsBasilIR.str> str
%type <AbsBasilIR.integerHex> integerHex
%type <AbsBasilIR.integerDec> integerDec

%%

pModuleT : moduleT TOK_EOF { $1 };

pDecl_list : decl_list TOK_EOF { $1 };

pBlockIdent_list : blockIdent_list TOK_EOF { $1 };

pLambdaSep : lambdaSep TOK_EOF { $1 };

pSemicolons : semicolons TOK_EOF { $1 };

pVarModifiers : varModifiers TOK_EOF { $1 };

pVarModifiers_list : varModifiers_list TOK_EOF { $1 };

pDecl : decl TOK_EOF { $1 };

pTypeT_list : typeT_list TOK_EOF { $1 };

pProcDef : procDef TOK_EOF { $1 };

pIntType : intType TOK_EOF { $1 };

pBoolType : boolType TOK_EOF { $1 };

pMapType : mapType TOK_EOF { $1 };

pBVType : bVType TOK_EOF { $1 };

pTypeT : typeT TOK_EOF { $1 };

pExpr_list : expr_list TOK_EOF { $1 };

pIntVal : intVal TOK_EOF { $1 };

pBVVal : bVVal TOK_EOF { $1 };

pEndian : endian TOK_EOF { $1 };

pAssignment : assignment TOK_EOF { $1 };

pStmt : stmt TOK_EOF { $1 };

pAssignment_list : assignment_list TOK_EOF { $1 };

pLocalVar : localVar TOK_EOF { $1 };

pGlobalVar : globalVar TOK_EOF { $1 };

pLocalVar_list : localVar_list TOK_EOF { $1 };

pVar : var TOK_EOF { $1 };

pGlobalVar_list : globalVar_list TOK_EOF { $1 };

pNamedCallReturn : namedCallReturn TOK_EOF { $1 };

pNamedCallReturn_list : namedCallReturn_list TOK_EOF { $1 };

pLVars : lVars TOK_EOF { $1 };

pNamedCallArg : namedCallArg TOK_EOF { $1 };

pNamedCallArg_list : namedCallArg_list TOK_EOF { $1 };

pCallParams : callParams TOK_EOF { $1 };

pJump : jump TOK_EOF { $1 };

pLVar : lVar TOK_EOF { $1 };

pLVar_list : lVar_list TOK_EOF { $1 };

pBlock_list : block_list TOK_EOF { $1 };

pStmtWithAttrib : stmtWithAttrib TOK_EOF { $1 };

pStmtWithAttrib_list : stmtWithAttrib_list TOK_EOF { $1 };

pJumpWithAttrib : jumpWithAttrib TOK_EOF { $1 };

pPhiExpr : phiExpr TOK_EOF { $1 };

pPhiExpr_list : phiExpr_list TOK_EOF { $1 };

pPhiAssign : phiAssign TOK_EOF { $1 };

pPhiAssign_list : phiAssign_list TOK_EOF { $1 };

pBlock : block TOK_EOF { $1 };

pAttrKeyValue : attrKeyValue TOK_EOF { $1 };

pAttrKeyValue_list : attrKeyValue_list TOK_EOF { $1 };

pAttribSet : attribSet TOK_EOF { $1 };

pAttr_list : attr_list TOK_EOF { $1 };

pAttr : attr TOK_EOF { $1 };

pParams : params TOK_EOF { $1 };

pParams_list : params_list TOK_EOF { $1 };

pFunParams : funParams TOK_EOF { $1 };

pFunParams_list : funParams_list TOK_EOF { $1 };

pValue : value TOK_EOF { $1 };

pExpr : expr TOK_EOF { $1 };

pLParen : lParen TOK_EOF { $1 };

pLParen_list : lParen_list TOK_EOF { $1 };

pLambdaDef : lambdaDef TOK_EOF { $1 };

pBinOp : binOp TOK_EOF { $1 };

pUnOp : unOp TOK_EOF { $1 };

pCase : case TOK_EOF { $1 };

pCase_list : case_list TOK_EOF { $1 };

pEqOp : eqOp TOK_EOF { $1 };

pBVUnOp : bVUnOp TOK_EOF { $1 };

pBVBinOp : bVBinOp TOK_EOF { $1 };

pBVLogicalBinOp : bVLogicalBinOp TOK_EOF { $1 };

pIntBinOp : intBinOp TOK_EOF { $1 };

pIntLogicalBinOp : intLogicalBinOp TOK_EOF { $1 };

pBoolBinOp : boolBinOp TOK_EOF { $1 };

pRequireTok : requireTok TOK_EOF { $1 };

pEnsureTok : ensureTok TOK_EOF { $1 };

pRelyTok : relyTok TOK_EOF { $1 };

pGuarTok : guarTok TOK_EOF { $1 };

pFunSpec : funSpec TOK_EOF { $1 };

pVarSpec : varSpec TOK_EOF { $1 };

pProgSpec : progSpec TOK_EOF { $1 };

pFunSpec_list : funSpec_list TOK_EOF { $1 };

pProgSpec_list : progSpec_list TOK_EOF { $1 };

moduleT : decl_list { Module1 $1 }
  ;

decl_list : /* empty */ { []  }
  | decl SYMB1 decl_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

blockIdent_list : /* empty */ { []  }
  | blockIdent { (fun x -> [x]) $1 }
  | blockIdent SYMB2 blockIdent_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

lambdaSep : SYMB3 { LambdaSep1  }
  | SYMB4 { LambdaSep2  }
  ;

semicolons : /* empty */ { Semicolons_Empty  }
  | semicolons SYMB1 { Semicolons_Some $1 }
  ;

varModifiers : KW_shared { Shared  }
  | KW_observable { Observable  }
  ;

varModifiers_list : /* empty */ { []  }
  | varModifiers varModifiers_list { (fun (x,xs) -> x::xs) ($1, $2) }
  ;

decl : KW_axiom globalIdent attribSet expr { Decl_Axiom ($2, $3, $4) }
  | KW_memory varModifiers_list globalIdent SYMB5 typeT varSpec { Decl_Mem ($2, $3, $5, $6) }
  | KW_var varModifiers_list globalIdent SYMB5 typeT varSpec { Decl_Var ($2, $3, $5, $6) }
  | KW_val globalIdent attribSet SYMB5 typeT { Decl_UninterpFun ($2, $3, $5) }
  | KW_let globalIdent attribSet SYMB5 typeT SYMB6 expr { Decl_Fun ($2, $3, $5, $7) }
  | KW_let globalIdent attribSet SYMB6 expr { Decl_FunNoType ($2, $3, $5) }
  | KW_prog KW_entry procIdent attribSet { Decl_ProgEmpty ($3, $4) }
  | KW_prog KW_entry procIdent attribSet progSpec_list { Decl_ProgWithSpec ($3, $4, $5) }
  | KW_proc procIdent openParen params_list closeParen SYMB3 openParen params_list closeParen attribSet funSpec_list procDef { Decl_Proc ($2, $3, $4, $5, $7, $8, $9, $10, $11, $12) }
  ;

typeT_list : /* empty */ { []  }
  | typeT { (fun x -> [x]) $1 }
  | typeT SYMB2 typeT_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

procDef : /* empty */ { ProcDef_Empty  }
  | beginList block_list endList { ProcDef_Some ($1, $2, $3) }
  ;

intType : iNTTYPE { IntType1 $1 }
  ;

boolType : bOOLTYPE { BoolType1 $1 }
  ;

mapType : typeT SYMB3 typeT { MapType1 ($1, $3) }
  ;

bVType : bVTYPE { BVType1 $1 }
  ;

typeT : intType { TypeIntType $1 }
  | boolType { TypeBoolType $1 }
  | mapType { TypeMapType $1 }
  | bVType { TypeBVType $1 }
  | openParen typeT closeParen { Type1 ($1, $2, $3) }
  ;

expr_list : /* empty */ { []  }
  | expr { (fun x -> [x]) $1 }
  | expr SYMB2 expr_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

intVal : integerHex { IntVal_Hex $1 }
  | integerDec { IntVal_Dec $1 }
  ;

bVVal : intVal SYMB5 bVType { BVVal1 ($1, $3) }
  ;

endian : KW_le { Endian_Little  }
  | KW_be { Endian_Big  }
  ;

assignment : lVar SYMB7 expr { Assignment1 ($1, $3) }
  ;

stmt : KW_nop { Stmt_Nop  }
  | assignment { Stmt_SingleAssign $1 }
  | lVar SYMB8 expr { Stmt_MemAssign ($1, $3) }
  | lVar SYMB7 KW_store expr { Stmt_ScalarStore ($1, $4) }
  | lVar SYMB7 KW_load var { Stmt_ScalarLoad ($1, $4) }
  | openParen assignment_list closeParen { Stmt_MultiAssign ($1, $2, $3) }
  | lVar SYMB7 KW_load endian globalIdent expr intVal { Stmt_Load ($1, $4, $5, $6, $7) }
  | KW_store endian globalIdent expr expr intVal { Stmt_Store ($2, $3, $4, $5, $6) }
  | lVar SYMB7 KW_load endian var expr intVal { Stmt_Load_Var ($1, $4, $5, $6, $7) }
  | lVar SYMB7 KW_store endian var expr expr intVal { Stmt_Store_Var ($1, $4, $5, $6, $7, $8) }
  | lVars KW_call procIdent openParen callParams closeParen { Stmt_DirectCall ($1, $3, $4, $5, $6) }
  | KW_indirect KW_call expr { Stmt_IndirectCall $3 }
  | KW_assume expr { Stmt_Assume $2 }
  | KW_guard expr { Stmt_Guard $2 }
  | KW_assert expr { Stmt_Assert $2 }
  ;

assignment_list : assignment { (fun x -> [x]) $1 }
  | assignment SYMB2 assignment_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

localVar : localIdent SYMB5 typeT { LocalTyped ($1, $3) }
  | localIdent { LocalUntyped $1 }
  ;

globalVar : globalIdent SYMB5 typeT { GlobalTyped ($1, $3) }
  | globalIdent { GlobalUntyped $1 }
  ;

localVar_list : localVar { (fun x -> [x]) $1 }
  | localVar SYMB2 localVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

var : localVar { VarLocalVar $1 }
  | globalVar { VarGlobalVar $1 }
  ;

globalVar_list : /* empty */ { []  }
  | globalVar { (fun x -> [x]) $1 }
  | globalVar SYMB2 globalVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

namedCallReturn : lVar SYMB6 localIdent { NamedCallReturn1 ($1, $3) }
  ;

namedCallReturn_list : /* empty */ { []  }
  | namedCallReturn { (fun x -> [x]) $1 }
  | namedCallReturn SYMB2 namedCallReturn_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

lVars : /* empty */ { LVars_Empty  }
  | KW_var openParen localVar_list closeParen SYMB7 { LVars_LocalList ($2, $3, $4) }
  | openParen lVar_list closeParen SYMB7 { LVars_List ($1, $2, $3) }
  | openParen namedCallReturn_list closeParen SYMB7 { NamedLVars_List ($1, $2, $3) }
  ;

namedCallArg : localIdent SYMB6 expr { NamedCallArg1 ($1, $3) }
  ;

namedCallArg_list : /* empty */ { []  }
  | namedCallArg { (fun x -> [x]) $1 }
  | namedCallArg SYMB2 namedCallArg_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

callParams : expr_list { CallParams_Exprs $1 }
  | namedCallArg_list { CallParams_Named $1 }
  ;

jump : KW_goto openParen blockIdent_list closeParen { Jump_GoTo ($2, $3, $4) }
  | KW_unreachable { Jump_Unreachable  }
  | KW_return openParen expr_list closeParen { Jump_Return ($2, $3, $4) }
  | KW_return { Jump_ProcReturn  }
  ;

lVar : KW_var localVar { LVar_Local $2 }
  | globalVar { LVar_Global $1 }
  ;

lVar_list : lVar { (fun x -> [x]) $1 }
  | lVar SYMB2 lVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block_list : /* empty */ { []  }
  | block { (fun x -> [x]) $1 }
  | block SYMB1 block_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

stmtWithAttrib : stmt attribSet { StmtWithAttrib1 ($1, $2) }
  ;

stmtWithAttrib_list : /* empty */ { []  }
  | stmtWithAttrib SYMB1 stmtWithAttrib_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

jumpWithAttrib : jump attribSet { JumpWithAttrib1 ($1, $2) }
  ;

phiExpr : blockIdent SYMB3 var { PhiExpr1 ($1, $3) }
  ;

phiExpr_list : /* empty */ { []  }
  | phiExpr { (fun x -> [x]) $1 }
  | phiExpr SYMB2 phiExpr_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

phiAssign : lVar SYMB7 KW_phi openParen phiExpr_list closeParen { PhiAssign1 ($1, $4, $5, $6) }
  ;

phiAssign_list : /* empty */ { []  }
  | phiAssign { (fun x -> [x]) $1 }
  | phiAssign SYMB2 phiAssign_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block : KW_block blockIdent attribSet beginList stmtWithAttrib_list jumpWithAttrib SYMB1 endList { Block_NoPhi ($2, $3, $4, $5, $6, $8) }
  | KW_block blockIdent attribSet beginList openParen phiAssign_list closeParen SYMB1 stmtWithAttrib_list jumpWithAttrib SYMB1 endList { Block_Phi ($2, $3, $4, $5, $6, $7, $9, $10, $12) }
  ;

attrKeyValue : bIdent SYMB6 attr { AttrKeyValue1 ($1, $3) }
  ;

attrKeyValue_list : /* empty */ { []  }
  | attrKeyValue { (fun x -> [x]) $1 }
  | attrKeyValue SYMB1 attrKeyValue_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

attribSet : beginRec attrKeyValue_list semicolons endRec { AttribSet_Some ($1, $2, $3, $4) }
  | /* empty */ { AttribSet_Empty  }
  ;

attr_list : /* empty */ { []  }
  | attr { (fun x -> [x]) $1 }
  | attr SYMB1 attr_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

attr : beginRec attrKeyValue_list semicolons endRec { Attr_Map ($1, $2, $3, $4) }
  | beginList attr_list endList { Attr_List ($1, $2, $3) }
  | value { Attr_Lit $1 }
  | expr { Attr_Expr $1 }
  | str { Attr_Str $1 }
  ;

params : localIdent SYMB5 typeT { Params1 ($1, $3) }
  ;

params_list : /* empty */ { []  }
  | params { (fun x -> [x]) $1 }
  | params SYMB2 params_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

funParams : localIdent SYMB5 typeT { FunParams1 ($1, $3) }
  | openParen localIdent SYMB5 typeT closeParen { FunParams2 ($1, $2, $4, $5) }
  ;

funParams_list : /* empty */ { []  }
  | funParams funParams_list { (fun (x,xs) -> x::xs) ($1, $2) }
  ;

value : bVVal { Value_BV $1 }
  | intVal { Value_Int $1 }
  | KW_true { Value_True  }
  | KW_false { Value_False  }
  ;

expr : value { Expr_Literal $1 }
  | openParen expr closeParen { Expr_Paren ($1, $2, $3) }
  | localVar { Expr_Local $1 }
  | globalVar { Expr_Global $1 }
  | KW_forall attribSet lambdaDef { Expr_Forall ($2, $3) }
  | KW_exists attribSet lambdaDef { Expr_Exists ($2, $3) }
  | KW_fun attribSet lambdaDef { Expr_Lambda ($2, $3) }
  | KW_old openParen expr closeParen { Expr_Old ($2, $3, $4) }
  | globalIdent openParen expr_list closeParen { Expr_FunctionOp ($1, $2, $3, $4) }
  | expr expr { Expr_Apply ($1, $2) }
  | binOp openParen expr SYMB2 expr closeParen { Expr_Binary ($1, $2, $3, $5, $6) }
  | boolBinOp openParen expr_list closeParen { Expr_Assoc ($1, $2, $3, $4) }
  | unOp openParen expr closeParen { Expr_Unary ($1, $2, $3, $4) }
  | KW_load_be openParen intVal SYMB2 expr SYMB2 expr closeParen { Expr_LoadBe ($2, $3, $5, $7, $8) }
  | KW_load_le openParen intVal SYMB2 expr SYMB2 expr closeParen { Expr_LoadLe ($2, $3, $5, $7, $8) }
  | KW_zero_extend openParen intVal SYMB2 expr closeParen { Expr_ZeroExtend ($2, $3, $5, $6) }
  | KW_sign_extend openParen intVal SYMB2 expr closeParen { Expr_SignExtend ($2, $3, $5, $6) }
  | KW_extract openParen intVal SYMB2 intVal SYMB2 expr closeParen { Expr_Extract ($2, $3, $5, $7, $8) }
  | KW_bvconcat openParen expr_list closeParen { Expr_Concat ($2, $3, $4) }
  | KW_match expr KW_with openParen case_list closeParen { Expr_Match ($2, $4, $5, $6) }
  | KW_cases openParen case_list closeParen { Expr_Cases ($2, $3, $4) }
  ;

lParen : localVar { LParenLocalVar $1 }
  | openParen localVar closeParen { LParen1 ($1, $2, $3) }
  ;

lParen_list : /* empty */ { []  }
  | lParen { (fun x -> [x]) $1 }
  | lParen SYMB2 lParen_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

lambdaDef : lParen_list lambdaSep expr { LambdaDef1 ($1, $2, $3) }
  ;

binOp : bVBinOp { BinOpBVBinOp $1 }
  | bVLogicalBinOp { BinOpBVLogicalBinOp $1 }
  | boolBinOp { BinOpBoolBinOp $1 }
  | intLogicalBinOp { BinOpIntLogicalBinOp $1 }
  | intBinOp { BinOpIntBinOp $1 }
  | eqOp { BinOpEqOp $1 }
  ;

unOp : bVUnOp { UnOpBVUnOp $1 }
  | KW_boolnot { UnOp_boolnot  }
  | KW_intneg { UnOp_intneg  }
  | KW_booltobv1 { UnOp_booltobv1  }
  | KW_gamma { UnOp_gamma  }
  | KW_classification { UnOp_classification  }
  ;

case : expr SYMB3 expr { CaseCase ($1, $3) }
  | SYMB9 SYMB3 expr { CaseDefault $3 }
  ;

case_list : /* empty */ { []  }
  | case { (fun x -> [x]) $1 }
  | case SYMB10 case_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

eqOp : KW_eq { EqOp_eq  }
  | KW_neq { EqOp_neq  }
  ;

bVUnOp : KW_bvnot { BVUnOp_bvnot  }
  | KW_bvneg { BVUnOp_bvneg  }
  ;

bVBinOp : KW_bvand { BVBinOp_bvand  }
  | KW_bvor { BVBinOp_bvor  }
  | KW_bvadd { BVBinOp_bvadd  }
  | KW_bvmul { BVBinOp_bvmul  }
  | KW_bvudiv { BVBinOp_bvudiv  }
  | KW_bvurem { BVBinOp_bvurem  }
  | KW_bvshl { BVBinOp_bvshl  }
  | KW_bvlshr { BVBinOp_bvlshr  }
  | KW_bvnand { BVBinOp_bvnand  }
  | KW_bvnor { BVBinOp_bvnor  }
  | KW_bvxor { BVBinOp_bvxor  }
  | KW_bvxnor { BVBinOp_bvxnor  }
  | KW_bvcomp { BVBinOp_bvcomp  }
  | KW_bvsub { BVBinOp_bvsub  }
  | KW_bvsdiv { BVBinOp_bvsdiv  }
  | KW_bvsrem { BVBinOp_bvsrem  }
  | KW_bvsmod { BVBinOp_bvsmod  }
  | KW_bvashr { BVBinOp_bvashr  }
  ;

bVLogicalBinOp : KW_bvule { BVLogicalBinOp_bvule  }
  | KW_bvugt { BVLogicalBinOp_bvugt  }
  | KW_bvuge { BVLogicalBinOp_bvuge  }
  | KW_bvult { BVLogicalBinOp_bvult  }
  | KW_bvslt { BVLogicalBinOp_bvslt  }
  | KW_bvsle { BVLogicalBinOp_bvsle  }
  | KW_bvsgt { BVLogicalBinOp_bvsgt  }
  | KW_bvsge { BVLogicalBinOp_bvsge  }
  ;

intBinOp : KW_intadd { IntBinOp_intadd  }
  | KW_intmul { IntBinOp_intmul  }
  | KW_intsub { IntBinOp_intsub  }
  | KW_intdiv { IntBinOp_intdiv  }
  | KW_intmod { IntBinOp_intmod  }
  ;

intLogicalBinOp : KW_intlt { IntLogicalBinOp_intlt  }
  | KW_intle { IntLogicalBinOp_intle  }
  | KW_intgt { IntLogicalBinOp_intgt  }
  | KW_intge { IntLogicalBinOp_intge  }
  ;

boolBinOp : KW_booland { BoolBinOp_booland  }
  | KW_boolor { BoolBinOp_boolor  }
  | KW_boolimplies { BoolBinOp_boolimplies  }
  ;

requireTok : KW_require { RequireTok_require  }
  | KW_requires { RequireTok_requires  }
  ;

ensureTok : KW_ensure { EnsureTok_ensure  }
  | KW_ensures { EnsureTok_ensures  }
  ;

relyTok : KW_rely { RelyTok_rely  }
  | KW_relies { RelyTok_relies  }
  ;

guarTok : KW_guarnatee { GuarTok_guarnatee  }
  | KW_guarantees { GuarTok_guarantees  }
  ;

funSpec : requireTok expr { FunSpec_Require ($1, $2) }
  | ensureTok expr { FunSpec_Ensure ($1, $2) }
  | relyTok expr { FunSpec_Rely ($1, $2) }
  | guarTok expr { FunSpec_Guar ($1, $2) }
  | KW_captures globalVar_list { FunSpec_Captures $2 }
  | KW_modifies globalVar_list { FunSpec_Modifies $2 }
  | KW_invariant blockIdent expr { FunSpec_Invariant ($2, $3) }
  ;

varSpec : KW_classification expr { VarSpec_Classification $2 }
  | /* empty */ { VarSpec_Empty  }
  ;

progSpec : KW_rely expr { ProgSpec_Rely $2 }
  | KW_guarantee expr { ProgSpec_Guarantee $2 }
  ;

funSpec_list : /* empty */ { []  }
  | funSpec SYMB1 funSpec_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

progSpec_list : /* empty */ { []  }
  | progSpec { (fun x -> [x]) $1 }
  | progSpec SYMB1 progSpec_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

bVTYPE : TOK_BVTYPE { BVTYPE ($1)};
iNTTYPE : TOK_INTTYPE { INTTYPE ($1)};
bOOLTYPE : TOK_BOOLTYPE { BOOLTYPE ($1)};
bIdent : TOK_BIdent { BIdent ($1)};
localIdent : TOK_LocalIdent { LocalIdent ($1)};
globalIdent : TOK_GlobalIdent { GlobalIdent ($1)};
blockIdent : TOK_BlockIdent { BlockIdent ($1)};
procIdent : TOK_ProcIdent { ProcIdent ($1)};
openParen : TOK_OpenParen { OpenParen ($1)};
closeParen : TOK_CloseParen { CloseParen ($1)};
beginList : TOK_BeginList { BeginList ($1)};
endList : TOK_EndList { EndList ($1)};
beginRec : TOK_BeginRec { BeginRec ($1)};
endRec : TOK_EndRec { EndRec ($1)};
str : TOK_Str { Str ($1)};
integerHex : TOK_IntegerHex { IntegerHex ($1)};
integerDec : TOK_IntegerDec { IntegerDec ($1)};

