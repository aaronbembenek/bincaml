
{0 Contributing to bincaml}

This guide explains who to get started as a contributor.


{1 Standard Library}

All files should import the [Bincaml_util.Common] library which contains extensions to
the OCaml standard library in the [containers] library, this is done by
depending on the [bincaml.util] library and putting at the top of the file.

[open Bincaml_util.Common]

Use the documentation for [containers] as a reference before the standard
library api docs (although it should be a superset).

Note that this library replaces the unsafe polymorphic equality operator [(=)] with [Int.Infix.(=)],
for equality use the relevant monomorphic equality (e.g. for strings) [String.equal], or [String.Infix.(=)],
with the appropriate module in place of [String].

{{:https://c-cube.github.io/ocaml-containers/3.15/containers/index.html}containers library documentation}

We also depend on {{:https://c-cube.github.io/ocaml-containers/3.15/containers-data/index.html}containers-data}

For common tasks, check whether these implement the neccessary functionality:

E.g.:

- file IO: {! module:Containers.CCIO } module
- pretty printing: {! Containers_pp }
- sexpr reading/writing: {! Containers.Sexp }

We make as much use as possible of the following dependencies:

- {{:https://ocaml.org/p/ocamlgraph}backtracking/ocamlgraph} for graph algorithms
- {{:https://ocaml.org/p/fix}fpottier/fix} for fixpoints and memoisation
- {{:https://c-cube.github.io/ocaml-containers}c-cube/containers-data} for common persistent and imperative datastructures
- {{:https://c-cube.github.io/iter}c-cube/iter} efficient lazy iterators with
    minimal allocations, use these as an intermediate structure for composing transformations
    instead of {!Stdlib.List} or {!Stdlib.Seq}

Check whether these implement what you need before re-implementing standard algorithms.


{1 CookBook}

{2 Implementing a Value Domain} 

+ Choose a good representation type and implement the lattice (order) operations, define
  a module implementing the {! Analysis.Lattice_types.Lattice} signature. 
+ Implement the abstraction functions for each expression operation by
  defining a module implementing the {! Analysis.Lattice_types.ValueAbstraction} signature
  signature for [type t = YourLattice.t].
+ Set up a soundness test using the property framework as describe in {!section-testvaluedomain}.
+ Fill out the set of operations in your vaue abstraction to increase precision 

It is a good idea to start with the lattice, ensure you have a good printer for
the values, and define all the evaluation functions as returning Top, and set
up the soundness test. You can then implement more operations and gradually
increase precision using the test to ensure your domain is sound.

{3 Run the analysis on an IL program}

+ Combine the Lattice ValueAbstraction these into an analysis using {! Analysis.Dataflow_graph.EasyForwardAnalysisPack}.
+ Set up a pass to run the analysis on an input file and print the result:
  {[
  let dfg_bool =
    {
      name = "demo-dfg-bool-analysis";
      apply = DFGAnalysis (module Analysis.Defuse_bool.Analysis);
      doc = "runs truthiness analysis on dataflow graph and prints results";
    }
  ]}
  And add the pass (in this case [dfg_bool]) to the [passes] list.
+ Save and run the following script with [dune exec script scriptname.sexp] for your analysis name:

{v
(load-il "examples/irreducible_loop_1.il")
(run-transforms "remove-unreachable-block" "cf-expressions" "intra-dead-store-elim")
(run-transforms "ssa")
(run-transforms "demo-dfg-bool-analysis")
v}

Find the complete example this guide refers in {{:https://github.com/agle/bincaml/blob/main/lib/analysis/defuse_bool.ml}lib/analysis/defuse_bool.ml}.


{2 Implementing Analyses }

1. An intraprocedural flow-insensitive single-pass analysis of an IR

Use {!Lang.Procedure.fold_blocks_topo_fwd} or {!Lang.Procedure.fold_blocks_topo_rev}.

To modify the procedure (returning a modified version, not modified in-place), use {! Lang.Procedure.map_blocks_topo_fwd}.

2. An intraprocedural flow-sensitive analysis of a non-ssa IR form with

Use the {{:https://backtracking.github.io/ocamlgraph/ocamlgraph/Graph/ChaoticIteration/index.html}Ocamlgraph
Bourdoncle chaotic iteration} fixed-point with widening.

The graph to use is {! Lang.Procedure.G} for forwards direction and {! Lang.Procedure.RevG} for
reverse direction.


{[
  Graph.ChaoticIteration.Make
    (Procedure.RevG)
    (struct
      open Procedure
      type vertex = RevG.E.vertex
      type edge = RevG.E.t
      type g = RevG.t
      type t = _
      let equal = _
      let join = _
      let widening a b = _

      let analyze (e : edge) data =
        match G.E.label e with Block b -> transfer_block_function d bata | _ -> data
    end)
  let analyse graph =
    let wto = Procedure.RevWTO.recursive_scc graph Procedure.Vert.Return
    in  LV.recurse graph wto
]}


3. For a simple forwards fixed-point over the call graph / block graph use {! module:Fix.Fixpoint }

See also {{:https://ocaml.org/p/fix/20250919/doc/fix/Fix/Fix/ForOrderedType/index.html}documentation for fix}

{[
module FixProp = Fix.Fix.ForOrderedType (Util.ID) (Domain:  sig
  type property = VS.t * VS.t
  val equal_property : property -> property -> bool
  val compare_property : property -> property -> int
  val bottom : VS.t * VS.t
  val equal : property -> property -> bool
  val compare : property -> property -> int
  val is_maximal : 'a -> bool
  val leq_join : property -> property -> property
  val to_string : property -> string
  val read : 'a * 'b -> 'a
  val written : 'a * 'b -> 'b
end)
(* transfer function for a node, e.g. id*)
let solve prog_proc =
  let equations (p : ID.t) (valuations : FixProp.valuation) =
      (* lookup block / proc id in prog_proc*)
      (* for successors, lookup their value in valuations *)
      _ in
  FixProp.lfp equations
]}


{2  Testing }

We have multiple kinds of testing

{4:testvaluedomain Value Abstraction Domain Soundness }

When implementing a single value abstraction we have a simple property test
framework set up to validate that the operator is sound according to the join.

This can be seen here. As long as the domain implements {! Analysis.Lattice_types.ValueAbstraction},
setting up this test is as simple as applying the functor and adding the resulting suite to the run list as 
in [test/lang/value_soundness.ml].

{[
module TestBoolDom =
  ValueAbstractionSoundness (Analysis.Defuse_bool.IsZeroValueAbstractionBasil)

let _ =
  Alcotest.run "value domain abstract eval soundness" [ TestBoolDom.suite ]
]}

{: https://github.com/agle/bincaml/blob/main/test/lang/value_soundness.ml#L54-L54}

This test can be run in isolation with 

{v
dune exec test/lang/value_soundness.exe
v}

{4 Property tests}

Property tests use the using [quickcheck] library and {!QCheck_alcotest} driver.

- see [test/lang/expr_eval_qcheck.ml]
- These define generators ({!QCheck.Gen}) for values to randomly test inputs to a given function.

{4 Expect tests }

Expectation tests using [ppx_expect_nobase]: see [test/lang/expr_expect]. These
assert the printed output matches a specific string

Expect tests can be created by writing

{[
let%expect_test "example test" = print_endline "hello world"
]}

Then running [dune test] will fail the test with a diff of the expected output. [dune promote] can then be used to set the result to the expected value.

{v
$ dune test
File "test/lang/expr_eval_expect.ml", line 1, characters 0-0:
------ test/lang/expr_eval_expect.ml
++++++ test/lang/expr_eval_expect.ml.corrected
File "test/lang/expr_eval_expect.ml", line 67, characters 0-1:
 |
!|let%expect_test "example test" = print_endline "hello world";
!|  [%expect {| hello world |}]
$ dune promote
Promoting _build/default/test/lang/expr_eval_expect.ml.corrected to
  test/lang/expr_eval_expect.ml.
 v}

These should be used with care:

{ol
  {- Do not print too much information that will make the test fail with any unrelated change: be precise in what is under test }
  {- Ensure the output is human-readable and clear}
}

see also: {{:https://blog.janestreet.com/the-joy-of-expect-tests/}writeup on expect tests}


{4 cram tests through dune }

Example: see [test/lang/cram/]

These are expected output tests for a shell script. For example,

{v
Ignored explanatory test

    $ echo "expected output for shell line"

    expected output
v}


They have similar characteristics to expected output tests; prefer use the
shell to test some property of the cli rather than the fact it has a specific
output.

More details are available in the {{:https://dune.readthedocs.io/en/stable/reference/cram.html}dune manual}.

{1 Debugging}

Ensure the opam switch is set up per the instructions in the readme: notably
that frame pointers are enabled. {{:https://lambdafoo.com/posts/2025-02-24-ocaml-frame-pointers.html}
This is the only reliable way to get stack samples on Ocaml 5}.

When dune is built in the develpment profile, (the default with [dune build]), it should
include debug information. 

{2 Functional}

Use a lot of assertions, assertions are fantastic, even better use exceptions.

Linux debugging tools are useful when dealing with logic errors that result in
crashes in external C libraries (such as zarith) due to API misue. Internal
library errors can be investigated with `strace` (the syscall trace program);
this can show you the sequence of syscalls that lead to a failure (e.g. an
extremely large allocation). 

OCaml 5 supports {{:https://web.archive.org/web/20251222014345/https://lambdafoo.com/posts/2024-08-03-lldb-ocaml.html} LLDB} 
and {{:https://web.archive.org/web/20251118091834/https://kcsrk.info/ocaml/gdb/2024/01/20/gdb-ocaml/} GDB}, 
however the support value printing is limited.

GDB is useful to have installed at least for the [pstack] command.

{2 Performance}

{3 Trace Events}

We use the {{:https://github.com/ocaml-tracing/ocaml-trace}trace library} to record coarse function runtimes, this is
enabled by default and every run dumps the tef format [trace.json] file. This
can be viewed in {{:ui.perfetto.dev} ui.perfetto.dev}. This provides coarse
performance info at the level of analysis passes.

Additional trace sections can be added like the following:

{[
let f x =
  Trace_core.with_span ~__FILE__ ~__LINE__ "inside-f" @@ fun _sp ->
  (* â€¦ code for f *)
]}


{3 Sampling}

Linux [perf] can be used to do sampling profiling of OCaml native executables,
this is covered in {{:https://ocaml.org/manual/5.4/profil.html#s:ocamlprof-profiling-perf} the manual}.
This provides fine-grained information on where the program is spending time.

There is a script which runs bincaml and produces a flamegraph (file [flamegraph.svg]) which can be viewed in a browser, 
e.g. [./tools/runperf.sh script examples/test.s] produces the following.

{{image!flamegraph.svg}Example flamegraph image}

{2 Nontermination}

Often what will appear to be a performance bug is actually a nontermination correctness bug.
One way to diagnose these is to print the stack while the program is running.  For example
we can get a rough idea of where in the program it is spending time by repeatedly printing the stack 
with [strace]:

{v
while true ; do pstack $(pgrep bincaml); sleep 0.5; done;
v}

(Here [pgrep bincaml] is finding the PID of the executable, you may need to adjust depending on how it was invoked.)

Additionally, OCaml 5 stores call stacks on the heap, and sets a very large
stack limit (500m), so reducing the stack limit  may help to debug by causing
the program to fail sooner, this can be done by the [OCAMLRUNPARAM] environment
variable.

{v
OCAMLRUNPARAM=l=1M dune exec bincaml script examples/test.s 
v}

{1 OCaml }

Install instrsuctions can be found on {{:https://ocaml.org/install#linux_mac_bsd}ocaml.org}

Ocaml is a somewhat niche langauge so we spend a few words on why and how we use it.

Cheifly it comes down to

- library availability: OCaml gets a lot of use in the formal methods / program
  analysis fields so there is a large corpus of open source implementations we
  can draw on
- functional programming: OCaml is a functional language with a strong static type system and good type inference
- simplicity of the language: while a functional langauge, OCaml is strict
  (expressions are evaluated immediately), and lacks a type-class system in favour of the module
  system. These make OCaml code usually very transparent to understand (although sometimes more verbose).
- good tooling: the build system; dune, the langauge server, the compiler are
  all fast and interactive and well suited to the research-code use case.

If you want more OCaml evangelism you can find it {{:https://xvw.lol/en/articles/why-ocaml.html}here}.


{3 Learning OCaml }

We recommend the textbook to Cornell's CS3110 functional programming course,
which is available for free on their
{{:https://cs3110.github.io/textbook/cover.html}website} and as
{{:https://cs3110.github.io/textbook/ocaml_programming.pdf}pdf}.

Also consider reviewing the {{:https://ocaml.org/manual/5.3/index.html}OCaml manual}.

{4 OCaml code search }

opam package Search by type signature: {{:https://doc.sherlocode.com}https://doc.sherlocode.com}

full source search of opam reposotiry {{:https://sherlocode.com/}https://sherlocode.com/}


{3 Setting up ocaml: }

We recommend you install the language server and dev setup packages:

{v
opam install ocaml-lsp-server
opam install --deps-only --with-dev-setup .
v}

[--with-dev-setup] includes [ocamlformat], [odig], [sherlodoc] this is useful for documentation search.

Use the following to build and open the documentation page for an installed package, here [containers]:

{v
odig doc containers
v}


It is good practice to hide implementations by interfaces, however in practice this often requires
a significant amount of code rewriting to define the module and its interface separately.
Some tricks can be used to simplify this process.

The following post describes a trick to reduce this duplication: {{:https://www.craigfe.io/posts/the-intf-trick}https://www.craigfe.io/posts/the-intf-trick}.

The following trick can also be used to write some code in a module that is not included in the outer module:

{[
open struct
 type t = int
  let (v:t) = v + 1
end
]}

{3 Documentation}

See {{:https://ocaml.github.io/odoc/odoc/odoc_for_authors.html} Odoc For
Authors for a guide to the documentation syntax.}
