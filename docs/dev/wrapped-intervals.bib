@mastersthesis{ananianStaticSingleInformation1999,
  title = {The {{Static Single Information Form}}},
  author = {Ananian, C. Scott},
  year = 1999,
  month = sep,
  school = {Massachusetts Institute of Technology}
}

@article{mineTutorialStaticInference2017,
  title = {Tutorial on {{Static Inference}} of {{Numeric Invariants}} by {{Abstract Interpretation}}},
  author = {Min{\'e}, Antoine},
  year = 2017,
  month = dec,
  journal = {Foundations and Trends in Programming Languages},
  volume = {4},
  number = {3-4},
  pages = {120--372},
  issn = {2325-1107, 2325-1131},
  doi = {10.1561/2500000034},
  urldate = {2026-02-12},
  abstract = {Born in the late 70s, Abstract Interpretation has proven an effective method to construct static analyzers. It has led to successful program analysis tools routinely used in avionic, automotive, and space industries to help ensuring the correctness of mission-critical software.             This tutorial presents Abstract Interpretation and its use to create static analyzers that infer numeric invariants on programs. We first present the theoretical bases of Abstract Interpretation: how to assign a well-defined formal semantics to programs, construct computable approximations to derive effective analyzers, and ensure soundness, i.e., any property derived by the analyzer is true of all actual executions --- although some properties may be missed due to approximations, a necessary compromise to keep the analysis automatic, sound, and terminating when inferring uncomputable properties. We describe the classic numeric abstractions readily available to an analysis designer: intervals, polyhedra, congruences, octagons, etc., as well as domain combiners: the reduced product and various disjunctive completions. This tutorial focuses not only on the semantic aspect, but also on the algorithmic one, providing a description of the data-structures and algorithms necessary to effectively implement all our abstractions. We will encounter many trade-offs between cost on the one hand, and precision and expressiveness on the other hand. Invariant inference is formalized on an idealized, toy-language, manipulating perfect numbers, but the principles and algorithms we present are effectively used in analyzers for real industrial programs, although this is out of the scope of this tutorial.             This tutorial is intended as an entry course in Abstract Interpretation, after which the reader should be ready to read the research literature on current advances in Abstract Interpretation and on the design of static analyzers for real languages.},
  langid = {english}
}

@incollection{navasSignednessAgnosticProgramAnalysis2012,
  title = {Signedness-{{Agnostic Program Analysis}}: {{Precise Integer Bounds}} for {{Low-Level Code}}},
  shorttitle = {Signedness-{{Agnostic Program Analysis}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Navas, Jorge A. and Schachte, Peter and S{\o}ndergaard, Harald and Stuckey, Peter J.},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Jhala, Ranjit and Igarashi, Atsushi},
  year = 2012,
  volume = {7705},
  pages = {115--130},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-35182-2_9},
  urldate = {2026-01-19},
  isbn = {978-3-642-35181-5 978-3-642-35182-2}
}

@misc{seahornCrabLibraryBuilding,
  title = {Crab: {{A C}}++ {{Library}} for {{Building Program Static Analyses}}},
  author = {{Seahorn}}
}

@book{warrenHackersDelight2013,
  title = {Hacker's {{Delight}}},
  author = {Warren, Henry S.},
  year = 2013,
  edition = {2nd ed},
  publisher = {Addison-Wesley},
  address = {Upper Saddle River, N.J},
  abstract = {In Hacker's Delight, Second Edition , Hank Warren once again compiles an irresistible collection of programming hacks: timesaving techniques, algorithms, and tricks that help programmers build more elegant and efficient software, while also gaining deeper insights into their craft. Warren's hacks are eminently practical, but they're also intrinsically interesting, and sometimes unexpected, much like the solution to a great puzzle. They are, in a word, a delight to any programmer who is excited by the opportunity to improve. Extensive additions in this edition include A new chapter on cyclic redundancy checking (CRC), including routines for the commonly used CRC-32 code A new chapter on error correcting codes (ECC), including routines for the Hamming code More coverage of integer division by constants, including methods using only shifts and adds Computing remainders without computing a quotient More coverage of population count and counting leading zeros Array population count New algorithms for compress and expand An LRU algorithm Floating-point to/from integer conversions Approximate floating-point reciprocal square root routine A gallery of graphs of discrete functions Now with exercises and answers},
  isbn = {978-0-321-84268-8 978-0-13-308499-3},
  langid = {english}
}
