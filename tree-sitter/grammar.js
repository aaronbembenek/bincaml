// File generated by the BNF Converter (bnfc 2.9.6.2).

module.exports = grammar({
  name: "basilir",
  extras: $ =>[
    /\s/,
    /\/\/.*\n/,
    /\/\*[^*]*\*([^\*\/][^*]*\*|\*)*\//,
  ],
  rules: {
    BNFCStart: $ =>
      optional(
        // BNFCStart_Module. BNFCStart ::= Module ;
        $.Module
      ),
    Module: $ =>
      // Module1. Module ::= [Decl] ;
      $.list_Decl,
    list_Decl: $ =>
      choice(
        // []. [Decl] ::= ;
        choice(),
        // (:). [Decl] ::= Decl ";" [Decl] ;
        seq($.Decl, ";", optional($.list_Decl))
      ),
    list_token_BlockIdent: $ =>
      choice(
        // []. [BlockIdent] ::= ;
        choice(),
        // (:[]). [BlockIdent] ::= BlockIdent ;
        $.token_BlockIdent,
        // (:). [BlockIdent] ::= BlockIdent "," [BlockIdent] ;
        seq($.token_BlockIdent, ",", optional($.list_token_BlockIdent))
      ),
    Semicolons: $ =>
      choice(
        // Semicolons_Empty. Semicolons ::= ;
        choice(),
        // Semicolons_Some. Semicolons ::= Semicolons ";" ;
        seq(optional($.Semicolons), ";")
      ),
    Decl: $ =>
      choice(
        // Decl_Axiom. Decl ::= "axiom" AttribSet Expr ;
        seq("axiom", optional($.AttribSet), $.Expr),
        // Decl_SharedMem. Decl ::= "memory" "shared" GlobalIdent ":" Type ;
        seq("memory", "shared", $.token_GlobalIdent, ":", $.Type),
        // Decl_UnsharedMem. Decl ::= "memory" GlobalIdent ":" Type ;
        seq("memory", $.token_GlobalIdent, ":", $.Type),
        // Decl_Var. Decl ::= "var" GlobalIdent ":" Type ;
        seq("var", $.token_GlobalIdent, ":", $.Type),
        // Decl_UninterpFun. Decl ::= "declare-fun" AttribSet GlobalIdent ":" "(" [Type] ")" "->" Type ;
        seq("declare-fun", optional($.AttribSet), $.token_GlobalIdent, ":", "(", optional($.list_Type), ")", "->", $.Type),
        // Decl_Fun. Decl ::= "define-fun" AttribSet GlobalIdent "(" [Params] ")" "->" Type "=" Expr ;
        seq("define-fun", optional($.AttribSet), $.token_GlobalIdent, "(", optional($.list_Params), ")", "->", $.Type, "=", $.Expr),
        // Decl_ProgEmpty. Decl ::= "prog" "entry" ProcIdent AttribSet ;
        seq("prog", "entry", $.token_ProcIdent, optional($.AttribSet)),
        // Decl_ProgWithSpec. Decl ::= "prog" "entry" ProcIdent AttribSet BeginList [ProgSpec] EndList ;
        seq("prog", "entry", $.token_ProcIdent, optional($.AttribSet), $.token_BeginList, optional($.list_ProgSpec), $.token_EndList),
        // Decl_Proc. Decl ::= "proc" ProcIdent "(" [Params] ")" "->" "(" [Params] ")" AttribSet [FunSpec] ProcDef ;
        seq("proc", $.token_ProcIdent, "(", optional($.list_Params), ")", "->", "(", optional($.list_Params), ")", optional($.AttribSet), optional($.list_FunSpec), optional($.ProcDef))
      ),
    list_Type: $ =>
      choice(
        // []. [Type] ::= ;
        choice(),
        // (:[]). [Type] ::= Type ;
        $.Type,
        // (:). [Type] ::= Type "," [Type] ;
        seq($.Type, ",", optional($.list_Type))
      ),
    ProcDef: $ =>
      choice(
        // ProcDef_Empty. ProcDef ::= ;
        choice(),
        // ProcDef_Some. ProcDef ::= BeginList [Block] EndList ;
        seq($.token_BeginList, optional($.list_Block), $.token_EndList)
      ),
    IntType: $ =>
      // IntType1. IntType ::= INTTYPE ;
      $.token_INTTYPE,
    BoolType: $ =>
      // BoolType1. BoolType ::= BOOLTYPE ;
      $.token_BOOLTYPE,
    MapType: $ =>
      // MapType1. MapType ::= "(" Type "->" Type ")" ;
      seq("(", $.Type, "->", $.Type, ")"),
    BVType: $ =>
      // BVType1. BVType ::= BVTYPE ;
      $.token_BVTYPE,
    Type: $ =>
      choice(
        // TypeIntType. Type ::= IntType ;
        $.IntType,
        // TypeBoolType. Type ::= BoolType ;
        $.BoolType,
        // TypeMapType. Type ::= MapType ;
        $.MapType,
        // TypeBVType. Type ::= BVType ;
        $.BVType
      ),
    list_Expr: $ =>
      choice(
        // []. [Expr] ::= ;
        choice(),
        // (:[]). [Expr] ::= Expr ;
        $.Expr,
        // (:). [Expr] ::= Expr "," [Expr] ;
        seq($.Expr, ",", optional($.list_Expr))
      ),
    IntVal: $ =>
      choice(
        // IntVal_Hex. IntVal ::= IntegerHex ;
        $.token_IntegerHex,
        // IntVal_Dec. IntVal ::= IntegerDec ;
        $.token_IntegerDec
      ),
    BVVal: $ =>
      // BVVal1. BVVal ::= IntVal ":" BVType ;
      seq($.IntVal, ":", $.BVType),
    Endian: $ =>
      choice(
        // Endian_Little. Endian ::= "le" ;
        "le",
        // Endian_Big. Endian ::= "be" ;
        "be"
      ),
    Assignment: $ =>
      // Assignment1. Assignment ::= LVar ":=" Expr ;
      seq($.LVar, ":=", $.Expr),
    Stmt: $ =>
      choice(
        // Stmt_Nop. Stmt ::= "nop" ;
        "nop",
        // Stmt_SingleAssign. Stmt ::= Assignment ;
        $.Assignment,
        // Stmt_MultiAssign. Stmt ::= "(" [Assignment] ")" ;
        seq("(", $.list_Assignment, ")"),
        // Stmt_Load. Stmt ::= LVar ":=" "load" Endian GlobalIdent Expr IntVal ;
        seq($.LVar, ":=", "load", $.Endian, $.token_GlobalIdent, $.Expr, $.IntVal),
        // Stmt_Store. Stmt ::= "store" Endian GlobalIdent Expr Expr IntVal ;
        seq("store", $.Endian, $.token_GlobalIdent, $.Expr, $.Expr, $.IntVal),
        // Stmt_Load_Var. Stmt ::= LVar ":=" "load" Endian Var Expr IntVal ;
        seq($.LVar, ":=", "load", $.Endian, $.Var, $.Expr, $.IntVal),
        // Stmt_Store_Var. Stmt ::= LVar ":=" "store" Endian Var Expr Expr IntVal ;
        seq($.LVar, ":=", "store", $.Endian, $.Var, $.Expr, $.Expr, $.IntVal),
        // Stmt_DirectCall. Stmt ::= LVars "call" ProcIdent "(" CallParams ")" ;
        seq(optional($.LVars), "call", $.token_ProcIdent, "(", optional($.CallParams), ")"),
        // Stmt_IndirectCall. Stmt ::= "indirect" "call" Expr ;
        seq("indirect", "call", $.Expr),
        // Stmt_Assume. Stmt ::= "assume" Expr ;
        seq("assume", $.Expr),
        // Stmt_Guard. Stmt ::= "guard" Expr ;
        seq("guard", $.Expr),
        // Stmt_Assert. Stmt ::= "assert" Expr ;
        seq("assert", $.Expr)
      ),
    list_Assignment: $ =>
      choice(
        // (:[]). [Assignment] ::= Assignment ;
        $.Assignment,
        // (:). [Assignment] ::= Assignment "," [Assignment] ;
        seq($.Assignment, ",", $.list_Assignment)
      ),
    LocalVar: $ =>
      // LocalVar1. LocalVar ::= LocalIdent ":" Type ;
      seq($.token_LocalIdent, ":", $.Type),
    GlobalVar: $ =>
      // GlobalVar1. GlobalVar ::= GlobalIdent ":" Type ;
      seq($.token_GlobalIdent, ":", $.Type),
    list_LocalVar: $ =>
      choice(
        // (:[]). [LocalVar] ::= LocalVar ;
        $.LocalVar,
        // (:). [LocalVar] ::= LocalVar "," [LocalVar] ;
        seq($.LocalVar, ",", $.list_LocalVar)
      ),
    Var: $ =>
      choice(
        // VarLocalVar. Var ::= LocalVar ;
        $.LocalVar,
        // VarGlobalVar. Var ::= GlobalVar ;
        $.GlobalVar
      ),
    NamedCallReturn: $ =>
      // NamedCallReturn1. NamedCallReturn ::= LVar "=" LocalIdent ;
      seq($.LVar, "=", $.token_LocalIdent),
    list_NamedCallReturn: $ =>
      choice(
        // []. [NamedCallReturn] ::= ;
        choice(),
        // (:[]). [NamedCallReturn] ::= NamedCallReturn ;
        $.NamedCallReturn,
        // (:). [NamedCallReturn] ::= NamedCallReturn "," [NamedCallReturn] ;
        seq($.NamedCallReturn, ",", optional($.list_NamedCallReturn))
      ),
    LVars: $ =>
      choice(
        // LVars_Empty. LVars ::= ;
        choice(),
        // LVars_LocalList. LVars ::= "var" "(" [LocalVar] ")" ":=" ;
        seq("var", "(", $.list_LocalVar, ")", ":="),
        // LVars_List. LVars ::= "(" [LVar] ")" ":=" ;
        seq("(", $.list_LVar, ")", ":="),
        // NamedLVars_List. LVars ::= "(" [NamedCallReturn] ")" ":=" ;
        seq("(", optional($.list_NamedCallReturn), ")", ":=")
      ),
    NamedCallArg: $ =>
      // NamedCallArg1. NamedCallArg ::= LocalIdent "=" Expr ;
      seq($.token_LocalIdent, "=", $.Expr),
    list_NamedCallArg: $ =>
      choice(
        // []. [NamedCallArg] ::= ;
        choice(),
        // (:[]). [NamedCallArg] ::= NamedCallArg ;
        $.NamedCallArg,
        // (:). [NamedCallArg] ::= NamedCallArg "," [NamedCallArg] ;
        seq($.NamedCallArg, ",", optional($.list_NamedCallArg))
      ),
    CallParams: $ =>
      choice(
        // CallParams_Exprs. CallParams ::= [Expr] ;
        $.list_Expr,
        // CallParams_Named. CallParams ::= [NamedCallArg] ;
        $.list_NamedCallArg
      ),
    Jump: $ =>
      choice(
        // Jump_GoTo. Jump ::= "goto" "(" [BlockIdent] ")" ;
        seq("goto", "(", optional($.list_token_BlockIdent), ")"),
        // Jump_Unreachable. Jump ::= "unreachable" ;
        "unreachable",
        // Jump_Return. Jump ::= "return" "(" [Expr] ")" ;
        seq("return", "(", optional($.list_Expr), ")"),
        // Jump_ProcReturn. Jump ::= "return" ;
        "return"
      ),
    LVar: $ =>
      choice(
        // LVar_Local. LVar ::= "var" LocalVar ;
        seq("var", $.LocalVar),
        // LVar_Global. LVar ::= GlobalVar ;
        $.GlobalVar
      ),
    list_LVar: $ =>
      choice(
        // (:[]). [LVar] ::= LVar ;
        $.LVar,
        // (:). [LVar] ::= LVar "," [LVar] ;
        seq($.LVar, ",", $.list_LVar)
      ),
    list_Block: $ =>
      choice(
        // []. [Block] ::= ;
        choice(),
        // (:[]). [Block] ::= Block ;
        $.Block,
        // (:). [Block] ::= Block ";" [Block] ;
        seq($.Block, ";", optional($.list_Block))
      ),
    StmtWithAttrib: $ =>
      // StmtWithAttrib1. StmtWithAttrib ::= Stmt AttribSet ;
      seq($.Stmt, optional($.AttribSet)),
    list_StmtWithAttrib: $ =>
      choice(
        // []. [StmtWithAttrib] ::= ;
        choice(),
        // (:). [StmtWithAttrib] ::= StmtWithAttrib ";" [StmtWithAttrib] ;
        seq($.StmtWithAttrib, ";", optional($.list_StmtWithAttrib))
      ),
    JumpWithAttrib: $ =>
      // JumpWithAttrib1. JumpWithAttrib ::= Jump AttribSet ;
      seq($.Jump, optional($.AttribSet)),
    PhiExpr: $ =>
      // PhiExpr1. PhiExpr ::= BlockIdent "->" Var ;
      seq($.token_BlockIdent, "->", $.Var),
    list_PhiExpr: $ =>
      choice(
        // []. [PhiExpr] ::= ;
        choice(),
        // (:[]). [PhiExpr] ::= PhiExpr ;
        $.PhiExpr,
        // (:). [PhiExpr] ::= PhiExpr "," [PhiExpr] ;
        seq($.PhiExpr, ",", optional($.list_PhiExpr))
      ),
    PhiAssign: $ =>
      // PhiAssign1. PhiAssign ::= LVar ":=" "phi" "(" [PhiExpr] ")" ;
      seq($.LVar, ":=", "phi", "(", optional($.list_PhiExpr), ")"),
    list_PhiAssign: $ =>
      choice(
        // []. [PhiAssign] ::= ;
        choice(),
        // (:[]). [PhiAssign] ::= PhiAssign ;
        $.PhiAssign,
        // (:). [PhiAssign] ::= PhiAssign "," [PhiAssign] ;
        seq($.PhiAssign, ",", optional($.list_PhiAssign))
      ),
    Block: $ =>
      choice(
        // Block_NoPhi. Block ::= "block" BlockIdent AttribSet BeginList [StmtWithAttrib] JumpWithAttrib ";" EndList ;
        seq("block", $.token_BlockIdent, optional($.AttribSet), $.token_BeginList, optional($.list_StmtWithAttrib), $.JumpWithAttrib, ";", $.token_EndList),
        // Block_Phi. Block ::= "block" BlockIdent AttribSet BeginList "(" [PhiAssign] ")" ";" [StmtWithAttrib] JumpWithAttrib ";" EndList ;
        seq("block", $.token_BlockIdent, optional($.AttribSet), $.token_BeginList, "(", optional($.list_PhiAssign), ")", ";", optional($.list_StmtWithAttrib), $.JumpWithAttrib, ";", $.token_EndList)
      ),
    AttrKeyValue: $ =>
      // AttrKeyValue1. AttrKeyValue ::= BIdent "=" Attr ;
      seq($.token_BIdent, "=", $.Attr),
    list_AttrKeyValue: $ =>
      choice(
        // []. [AttrKeyValue] ::= ;
        choice(),
        // (:[]). [AttrKeyValue] ::= AttrKeyValue ;
        $.AttrKeyValue,
        // (:). [AttrKeyValue] ::= AttrKeyValue ";" [AttrKeyValue] ;
        seq($.AttrKeyValue, ";", optional($.list_AttrKeyValue))
      ),
    AttribSet: $ =>
      choice(
        // AttribSet_Some. AttribSet ::= BeginRec [AttrKeyValue] EndRec ;
        seq($.token_BeginRec, optional($.list_AttrKeyValue), $.token_EndRec),
        // AttribSet_Empty. AttribSet ::= ;
        choice()
      ),
    list_Attr: $ =>
      choice(
        // []. [Attr] ::= ;
        choice(),
        // (:[]). [Attr] ::= Attr ;
        $.Attr,
        // (:). [Attr] ::= Attr ";" [Attr] ;
        seq($.Attr, ";", optional($.list_Attr))
      ),
    Attr: $ =>
      choice(
        // Attr_Map. Attr ::= BeginRec [AttrKeyValue] EndRec ;
        seq($.token_BeginRec, optional($.list_AttrKeyValue), $.token_EndRec),
        // Attr_List. Attr ::= BeginList [Attr] EndList ;
        seq($.token_BeginList, optional($.list_Attr), $.token_EndList),
        // Attr_Lit. Attr ::= Value ;
        $.Value,
        // Attr_Str. Attr ::= Str ;
        $.token_Str
      ),
    Params: $ =>
      // Params1. Params ::= LocalIdent ":" Type ;
      seq($.token_LocalIdent, ":", $.Type),
    list_Params: $ =>
      choice(
        // []. [Params] ::= ;
        choice(),
        // (:[]). [Params] ::= Params ;
        $.Params,
        // (:). [Params] ::= Params "," [Params] ;
        seq($.Params, ",", optional($.list_Params))
      ),
    Value: $ =>
      choice(
        // Value_BV. Value ::= BVVal ;
        $.BVVal,
        // Value_Int. Value ::= IntVal ;
        $.IntVal,
        // Value_True. Value ::= "true" ;
        "true",
        // Value_False. Value ::= "false" ;
        "false"
      ),
    Expr: $ =>
      choice(
        // Expr_Literal. Expr ::= Value ;
        $.Value,
        // Expr_Local. Expr ::= LocalVar ;
        $.LocalVar,
        // Expr_Global. Expr ::= GlobalVar ;
        $.GlobalVar,
        // Expr_Forall. Expr ::= "forall" LambdaDef ;
        seq("forall", $.LambdaDef),
        // Expr_Exists. Expr ::= "exists" LambdaDef ;
        seq("exists", $.LambdaDef),
        // Expr_Old. Expr ::= "old" "(" Expr ")" ;
        seq("old", "(", $.Expr, ")"),
        // Expr_FunctionOp. Expr ::= GlobalIdent "(" [Expr] ")" ;
        seq($.token_GlobalIdent, "(", optional($.list_Expr), ")"),
        // Expr_Binary. Expr ::= BinOp "(" Expr "," Expr ")" ;
        seq($.BinOp, "(", $.Expr, ",", $.Expr, ")"),
        // Expr_Assoc. Expr ::= BoolBinOp "(" [Expr] ")" ;
        seq($.BoolBinOp, "(", optional($.list_Expr), ")"),
        // Expr_Unary. Expr ::= UnOp "(" Expr ")" ;
        seq($.UnOp, "(", $.Expr, ")"),
        // Expr_ZeroExtend. Expr ::= "zero_extend" "(" IntVal "," Expr ")" ;
        seq("zero_extend", "(", $.IntVal, ",", $.Expr, ")"),
        // Expr_SignExtend. Expr ::= "sign_extend" "(" IntVal "," Expr ")" ;
        seq("sign_extend", "(", $.IntVal, ",", $.Expr, ")"),
        // Expr_Extract. Expr ::= "extract" "(" IntVal "," IntVal "," Expr ")" ;
        seq("extract", "(", $.IntVal, ",", $.IntVal, ",", $.Expr, ")"),
        // Expr_Concat. Expr ::= "bvconcat" "(" [Expr] ")" ;
        seq("bvconcat", "(", optional($.list_Expr), ")")
      ),
    LambdaDef: $ =>
      // LambdaDef1. LambdaDef ::= "(" [LocalVar] ")" LambdaSep Expr ;
      seq("(", $.list_LocalVar, ")", $.token_LambdaSep, $.Expr),
    BinOp: $ =>
      choice(
        // BinOpBVBinOp. BinOp ::= BVBinOp ;
        $.BVBinOp,
        // BinOpBVLogicalBinOp. BinOp ::= BVLogicalBinOp ;
        $.BVLogicalBinOp,
        // BinOpIntLogicalBinOp. BinOp ::= IntLogicalBinOp ;
        $.IntLogicalBinOp,
        // BinOpIntBinOp. BinOp ::= IntBinOp ;
        $.IntBinOp,
        // BinOpEqOp. BinOp ::= EqOp ;
        $.EqOp
      ),
    UnOp: $ =>
      choice(
        // UnOpBVUnOp. UnOp ::= BVUnOp ;
        $.BVUnOp,
        // UnOp_boolnot. UnOp ::= "boolnot" ;
        "boolnot",
        // UnOp_intneg. UnOp ::= "intneg" ;
        "intneg",
        // UnOp_booltobv1. UnOp ::= "booltobv1" ;
        "booltobv1"
      ),
    EqOp: $ =>
      choice(
        // EqOp_eq. EqOp ::= "eq" ;
        "eq",
        // EqOp_neq. EqOp ::= "neq" ;
        "neq"
      ),
    BVUnOp: $ =>
      choice(
        // BVUnOp_bvnot. BVUnOp ::= "bvnot" ;
        "bvnot",
        // BVUnOp_bvneg. BVUnOp ::= "bvneg" ;
        "bvneg"
      ),
    BVBinOp: $ =>
      choice(
        // BVBinOp_bvand. BVBinOp ::= "bvand" ;
        "bvand",
        // BVBinOp_bvor. BVBinOp ::= "bvor" ;
        "bvor",
        // BVBinOp_bvadd. BVBinOp ::= "bvadd" ;
        "bvadd",
        // BVBinOp_bvmul. BVBinOp ::= "bvmul" ;
        "bvmul",
        // BVBinOp_bvudiv. BVBinOp ::= "bvudiv" ;
        "bvudiv",
        // BVBinOp_bvurem. BVBinOp ::= "bvurem" ;
        "bvurem",
        // BVBinOp_bvshl. BVBinOp ::= "bvshl" ;
        "bvshl",
        // BVBinOp_bvlshr. BVBinOp ::= "bvlshr" ;
        "bvlshr",
        // BVBinOp_bvnand. BVBinOp ::= "bvnand" ;
        "bvnand",
        // BVBinOp_bvnor. BVBinOp ::= "bvnor" ;
        "bvnor",
        // BVBinOp_bvxor. BVBinOp ::= "bvxor" ;
        "bvxor",
        // BVBinOp_bvxnor. BVBinOp ::= "bvxnor" ;
        "bvxnor",
        // BVBinOp_bvcomp. BVBinOp ::= "bvcomp" ;
        "bvcomp",
        // BVBinOp_bvsub. BVBinOp ::= "bvsub" ;
        "bvsub",
        // BVBinOp_bvsdiv. BVBinOp ::= "bvsdiv" ;
        "bvsdiv",
        // BVBinOp_bvsrem. BVBinOp ::= "bvsrem" ;
        "bvsrem",
        // BVBinOp_bvsmod. BVBinOp ::= "bvsmod" ;
        "bvsmod",
        // BVBinOp_bvashr. BVBinOp ::= "bvashr" ;
        "bvashr"
      ),
    BVLogicalBinOp: $ =>
      choice(
        // BVLogicalBinOp_bvule. BVLogicalBinOp ::= "bvule" ;
        "bvule",
        // BVLogicalBinOp_bvugt. BVLogicalBinOp ::= "bvugt" ;
        "bvugt",
        // BVLogicalBinOp_bvuge. BVLogicalBinOp ::= "bvuge" ;
        "bvuge",
        // BVLogicalBinOp_bvult. BVLogicalBinOp ::= "bvult" ;
        "bvult",
        // BVLogicalBinOp_bvslt. BVLogicalBinOp ::= "bvslt" ;
        "bvslt",
        // BVLogicalBinOp_bvsle. BVLogicalBinOp ::= "bvsle" ;
        "bvsle",
        // BVLogicalBinOp_bvsgt. BVLogicalBinOp ::= "bvsgt" ;
        "bvsgt",
        // BVLogicalBinOp_bvsge. BVLogicalBinOp ::= "bvsge" ;
        "bvsge"
      ),
    IntBinOp: $ =>
      choice(
        // IntBinOp_intadd. IntBinOp ::= "intadd" ;
        "intadd",
        // IntBinOp_intmul. IntBinOp ::= "intmul" ;
        "intmul",
        // IntBinOp_intsub. IntBinOp ::= "intsub" ;
        "intsub",
        // IntBinOp_intdiv. IntBinOp ::= "intdiv" ;
        "intdiv",
        // IntBinOp_intmod. IntBinOp ::= "intmod" ;
        "intmod"
      ),
    IntLogicalBinOp: $ =>
      choice(
        // IntLogicalBinOp_intlt. IntLogicalBinOp ::= "intlt" ;
        "intlt",
        // IntLogicalBinOp_intle. IntLogicalBinOp ::= "intle" ;
        "intle",
        // IntLogicalBinOp_intgt. IntLogicalBinOp ::= "intgt" ;
        "intgt",
        // IntLogicalBinOp_intge. IntLogicalBinOp ::= "intge" ;
        "intge"
      ),
    BoolBinOp: $ =>
      choice(
        // BoolBinOp_booland. BoolBinOp ::= "booland" ;
        "booland",
        // BoolBinOp_boolor. BoolBinOp ::= "boolor" ;
        "boolor",
        // BoolBinOp_boolimplies. BoolBinOp ::= "boolimplies" ;
        "boolimplies"
      ),
    RequireTok: $ =>
      choice(
        // RequireTok_require. RequireTok ::= "require" ;
        "require",
        // RequireTok_requires. RequireTok ::= "requires" ;
        "requires"
      ),
    EnsureTok: $ =>
      choice(
        // EnsureTok_ensure. EnsureTok ::= "ensure" ;
        "ensure",
        // EnsureTok_ensures. EnsureTok ::= "ensures" ;
        "ensures"
      ),
    FunSpec: $ =>
      choice(
        // FunSpec_Require. FunSpec ::= RequireTok Expr ;
        seq($.RequireTok, $.Expr),
        // FunSpec_Ensure. FunSpec ::= EnsureTok Expr ;
        seq($.EnsureTok, $.Expr),
        // FunSpec_Invariant. FunSpec ::= "invariant" BlockIdent Expr ;
        seq("invariant", $.token_BlockIdent, $.Expr)
      ),
    ProgSpec: $ =>
      choice(
        // ProgSpec_Rely. ProgSpec ::= "rely" Expr ;
        seq("rely", $.Expr),
        // ProgSpec_Guarantee. ProgSpec ::= "guarantee" Expr ;
        seq("guarantee", $.Expr)
      ),
    list_FunSpec: $ =>
      choice(
        // []. [FunSpec] ::= ;
        choice(),
        // (:). [FunSpec] ::= FunSpec ";" [FunSpec] ;
        seq($.FunSpec, ";", optional($.list_FunSpec))
      ),
    list_ProgSpec: $ =>
      choice(
        // []. [ProgSpec] ::= ;
        choice(),
        // (:). [ProgSpec] ::= ProgSpec ";" [ProgSpec] ;
        seq($.ProgSpec, ";", optional($.list_ProgSpec))
      ),
    token_BVTYPE: $ =>
      /bv\d+/,
    token_INTTYPE: $ =>
      /int/,
    token_BOOLTYPE: $ =>
      /bool/,
    token_BIdent: $ =>
      /\.(_|[a-zA-Z])([#\$\._~]|(\d|[a-zA-Z]))*/,
    token_LocalIdent: $ =>
      /([#_]|[a-zA-Z])([#\$\._]|(\d|[a-zA-Z]))*/,
    token_GlobalIdent: $ =>
      /\$([#\$\._]|(\d|[a-zA-Z]))+/,
    token_BlockIdent: $ =>
      /%([#\$\._]|(\d|[a-zA-Z]))+/,
    token_ProcIdent: $ =>
      /@([#\$\._]|(\d|[a-zA-Z]))+/,
    token_BeginList: $ =>
      /\[/,
    token_EndList: $ =>
      /\]/,
    token_BeginRec: $ =>
      /\{/,
    token_EndRec: $ =>
      /\}/,
    token_LambdaSep: $ =>
      /::|->/,
    token_Str: $ =>
      /"([^"\\]|\\["\\fnrt])*"/,
    token_IntegerHex: $ =>
      /0x([abcdef]|\d)+/,
    token_IntegerDec: $ =>
      /\d+/,
  },
});
